MODULE propagator_mod
  ! Module to handle Propagators for Neo2
  !
  ! External programs:
  !   subroutine ripple_solver
  !   subroutine join_ripples
  !
  ! Called through programs:
  !   subroutine propagator_solver
  !
  ! ATTENTION:
  !  
  !  If physical content is changed then pertinent changes have to
  !  be made in several places!
  !
  ! External quantities: <default>
  !  prop_timing      0: no timing; <1: timing of module>
  !  prop_diagnostic  0: no diagnostic; <1: normal>; 2: extented 
  !  prop_binary      0: normal joining; <1: binary joining> 
  !  
  ! TODO: Make it save for subsequent calls to flint
  !
  ! Winfried Kernbichler 19.08.2004
  !
  ! ---------------------------------------------------------------------------
  ! ---------------------------------------------------------------------------

  ! ---------------------------------------------------------------------------
  ! ---------------------------------------------------------------------------
  ! mnemonics
  !  
  ! "_p" - means "plus"  - particles with positive velocity (left  to right)
  ! "_m" - means "minus" - particles with negative velocity (right to left )
  !
  ! ---------------------------------------------------------------------------
  ! dimensions
  !
  ! npart          - number of particles
  ! npass_l        - number of passing particles on the left  side
  ! npass_r        - number of passing particles on the right side 
  ! npart_halfband
  !
  ! ---------------------------------------------------------------------------
  ! flux and current (from the outside)
  !
  ! flux_p(npass_l) - particles enter with positive velocity from the left side 
  ! flux_m(npass_r) - particles enter with negative velocity from the left side
  ! curr_p(npass_l) - particles enter with positive velocity from the left side 
  ! curr_m(npass_r) - particles enter with negative velocity from the left side
  !
  ! ---------------------------------------------------------------------------
  ! sources (internal)
  !  this is a distribution of particles generated by
  !  internal sources in the ripple which are leaving the ripple
  !
  ! source_p_*(npass_r) - positive velocity leaving on right side
  ! source_m_*(npass_l) - negative velocity leaving on left  side
  !
  !  * can be g (gradient driven) or _e (parallel electric field driven)
  !
  ! ---------------------------------------------------------------------------
  ! matrices
  !
  ! amat_p_m(exit,entry) - enter with positive velocity (entry left) and
  !                        leave with negative velocity (exit  left)
  !
  ! amat_p_m(npass_l,npass_l)
  ! amat_m_p(npass_r,npass_r)
  ! amat_p_p(npass_r,npass_l)
  ! amat_m_m(npass_l,npass_r)
  !
  ! ---------------------------------------------------------------------------
  ! ---------------------------------------------------------------------------


  USE binarysplit_mod

  !*********************************************
  ! MPI Support
  ! Sources have to be compiled with -cpp flag
  ! For using this parallel framework the compiler has to support Fortran 2003 standards
  !*********************************************
#if defined(MPI_SUPPORT)
  USE mpiprovider_module
#endif
  ! ---

  !****************************
  ! HDF5 Interface
  !****************************
  use hdf5_tools
  use hdf5_tools_f2003

  IMPLICIT NONE
  
  ! ---------------------------------------------------------------------------
  ! private variables
  INTEGER, PARAMETER, PRIVATE :: dp = KIND(1.0D0)
  REAL(kind=dp),      PRIVATE :: time_o
  REAL(kind=dp),      PRIVATE :: time_co,time_jp,time_ja,time_jf,time_so
  REAL(kind=dp),      PRIVATE :: stime_co,stime_jp,stime_ja,stime_jf,stime_so
  REAL(kind=dp),      PRIVATE :: stime_tot = 0.0_dp, time_tot,time_tot_o
  REAL(kind=dp), PARAMETER, PRIVATE :: pi=3.14159265358979d0
  INTEGER,            PRIVATE :: propagator_tag_counter = 0

  CHARACTER(len=9),   PARAMETER, PUBLIC          :: prop_format = 'formatted'
  CHARACTER(len=4),   PUBLIC                     :: prop_cext = 'prop'
  CHARACTER(len=6),   PARAMETER, PRIVATE         :: prop_cperiod = 'period'
  CHARACTER(len=10),  PARAMETER, PRIVATE         :: prop_cpropagator = 'propagator'
  CHARACTER(len=8),   PARAMETER, PRIVATE         :: prop_cboundary = 'boundary'
  CHARACTER(len=11),  PARAMETER, PRIVATE         :: prop_cbinarysplit = 'binarysplit'
  CHARACTER(len=12),  PARAMETER, PUBLIC          :: prop_ctaginfo = 'taginfo.prop'
  CHARACTER(len=10),  PARAMETER, PUBLIC          :: prop_ctaginfo_nc = 'taginfo.nc'   ! NetCDF
  CHARACTER(len=16),  PARAMETER, PRIVATE         :: prop_cresult = 'reconstruct'
  CHARACTER(len=100),            PUBLIC          :: prop_cfilename
  INTEGER,                       PUBLIC          :: prop_unit = 150
  INTEGER,                       PRIVATE         :: prop_first_tag = 0
  INTEGER,                       PRIVATE         :: prop_last_tag = 0


  
  ! ---------------------------------------------------------------------------


  ! public variables (input file)
  INTEGER,            PUBLIC  :: prop_diagphys 
  INTEGER,            PUBLIC  :: prop_overwrite 
  INTEGER,            PUBLIC  :: prop_diagnostic = 1
  INTEGER,            PUBLIC  :: prop_binary = 0
  INTEGER,            PUBLIC  :: prop_timing = 1
  INTEGER,            PUBLIC  :: prop_join_ends = 0
  INTEGER,            PUBLIC  :: prop_fluxsplitmode = 1
  INTEGER,            PUBLIC  :: prop_write = 0
  INTEGER,            PUBLIC  :: prop_fileformat = 0     ! 0... ACSII, 1... HDF5
  INTEGER,            PUBLIC  :: prop_reconstruct = 0
  INTEGER,            PUBLIC  :: prop_ripple_plot = 0
  ! usage for communication purposes
  INTEGER,            PUBLIC  :: prop_count_call = 0
  INTEGER,            PUBLIC  :: prop_ibegperiod = 1
  INTEGER,            PUBLIC  :: prop_modifyold = 1
  logical                     :: lsw_save_dentf = .true.
  logical                     :: lsw_save_enetf = .true. 
  logical                     :: lsw_save_spitf = .true.
  !
  ! fluxes after reconstruction
  REAL(kind=dp), ALLOCATABLE, PUBLIC  :: flux_mr(:,:),flux_pl(:,:)
  REAL(kind=dp),              PUBLIC  :: eta_modboundary_l,eta_modboundary_r
  INTEGER,                    PUBLIC  :: sw_first_prop,sw_last_prop
  !
  ! new switch for reconstruction of levels
  INTEGER,            PUBLIC  :: prop_reconstruct_levels = 0

  INTEGER                     :: prop_finaljoin_mode = 0

  
  
  ! ***************************
  ! HDF5
  ! ***************************
  integer(HID_T) :: h5id


  ! ---------------------------------------------------------------------------
  ! type declaration for propagator physics
  !  with gradients _g and parallel electric field _e
  PUBLIC prop_qe
  TYPE prop_qe
     INTEGER                                    :: npart
     INTEGER                                    :: npass_l
     INTEGER                                    :: npass_r
     INTEGER                                    :: nvelocity                !<-in
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: amat_p_p
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: amat_m_m
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: amat_p_m
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: amat_m_p
     REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_p              !<-in
     REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_m              !<-in
     REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: flux_p                !<-in
     REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: flux_m                !<-in
     REAL(kind=dp), DIMENSION(:,:),       ALLOCATABLE :: qflux             !<-in
     !
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: cmat
     !
     ! eta at left and right boundary
     REAL(kind=dp), DIMENSION(:),   ALLOCATABLE :: eta_l
     REAL(kind=dp), DIMENSION(:),   ALLOCATABLE :: eta_r
     REAL(kind=dp)                              :: eta_boundary_l
     REAL(kind=dp)                              :: eta_boundary_r
     !
     ! working field for intermediate storage during reallocation
     REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: w
  END TYPE prop_qe
  
  PUBLIC prop_boundary
  TYPE prop_boundary
          REAL(kind=dp)  :: fieldpropagator_tag_left
          REAL(kind=dp)  :: fieldpropagator_tag_right
          REAL(kind=dp)  :: fieldperiod_tag_left
          REAL(kind=dp)  :: fieldperiod_tag_right
          REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: c_forward
          REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE :: c_backward
  END TYPE prop_boundary

  ! ---------------------------------------------------------------------------
  ! type declaration for propagator
  PUBLIC propagator
  TYPE propagator
     ! internal service pointers: Links to previous and next propagator
     TYPE(propagator),              POINTER     :: prev => NULL()
     TYPE(propagator),              POINTER     :: next => NULL()
     ! internal service quantity: Current usage of propagator
     !  not allocated   -3
     !  allocated       -2
     !  used            -1
     !  containing sums >= 0
     !   0: 2^0 - 1 period
     !   1: 2^1 - 2 periods
     !   2: 2^2 - 4 periods ....
     INTEGER                                    :: tag = 0
     INTEGER                                    :: nr_joined = -3
     ! physical quantities
     ! have to be changed if pyhsics changes!
     !  see also: deallocate_propagator_cont    (deallocation)
     !            propagator_solver_int         (propagator solver)
     !            ripple_solver_int             (ripple solver)
     !            join_ripples_int              (joining ripples)
     !          
     INTEGER                                    :: bin_split_mode
     TYPE(binarysplit)                          :: eta_bs_l
     TYPE(binarysplit)                          :: eta_bs_r

     ! tag of fieldpropagator (start, end)
     INTEGER                                    :: fieldpropagator_tag_s
     INTEGER                                    :: fieldpropagator_tag_e
     INTEGER                                    :: fieldperiod_tag_s
     INTEGER                                    :: fieldperiod_tag_e
     ! y values from RK equation solver at end of propagator
     REAL(kind=dp), ALLOCATABLE                 :: y(:)
     ! phi value at left and right side
     REAL(kind=dp)                              :: phi_l
     REAL(kind=dp)                              :: phi_r
     ! real propagator content
     TYPE(prop_qe)                              :: p
  END TYPE propagator

  ! ---------------------------------------------------------------------------
  ! private propagators
  TYPE(propagator), POINTER, PRIVATE            :: prop_a => NULL() ! actual for diag
  TYPE(propagator), POINTER, PUBLIC             :: prop_r => NULL() ! root                 !Had to set PUBLIC for parallel support
  TYPE(propagator), POINTER, PUBLIC             :: prop_c => NULL() ! current
  TYPE(propagator), POINTER, PRIVATE            :: prop_n => NULL() ! new
  TYPE(propagator), POINTER, PRIVATE            :: prop_l => NULL() ! last
  ! only for join_ripples_bsfitsplit and join_ripples_bsfitjoin
  TYPE(propagator), POINTER, PUBLIC             :: prop_c_old => NULL()
  TYPE(propagator), POINTER, PUBLIC             :: prop_c_new => NULL()

  ! For parallel support, every client gets its own evolve.dat file
  character(len=32) :: evolveFilename
  
  ! ---------------------------------------------------------------------------
  ! public routines for propagator handling
  PUBLIC  propagator_solver
  PRIVATE propagator_solver_loc,propagator_solver_all
  INTERFACE propagator_solver
     MODULE PROCEDURE propagator_solver_loc,propagator_solver_all
  END INTERFACE

  PUBLIC write_propagator_content
  PRIVATE write_propagator_cont
  INTERFACE write_propagator_content
     MODULE PROCEDURE write_propagator_cont
  END INTERFACE

  PUBLIC write_binarysplit_content
  PRIVATE write_binarysplit_cont
  INTERFACE write_binarysplit_content
     MODULE PROCEDURE write_binarysplit_cont
  END INTERFACE

  PUBLIC reconstruct_prop_dist
  PRIVATE reconstruct_propagator_dist,reconstruct_propagator_dist_1
  INTERFACE reconstruct_prop_dist
     MODULE PROCEDURE reconstruct_propagator_dist,reconstruct_propagator_dist_1
  END INTERFACE

  PUBLIC write_prop_bound_content
  PRIVATE write_prop_bound_cont
  INTERFACE write_prop_bound_content
     MODULE PROCEDURE write_prop_bound_cont
  END INTERFACE

  PUBLIC read_propagator_content
  PRIVATE read_propagator_cont
  INTERFACE read_propagator_content
     MODULE PROCEDURE read_propagator_cont
  END INTERFACE

  PUBLIC read_binarysplit_content
  PRIVATE read_binarysplit_cont
  INTERFACE read_binarysplit_content
     MODULE PROCEDURE read_binarysplit_cont
  END INTERFACE

  PUBLIC read_prop_bound_content
  PRIVATE read_prop_bound_cont
  INTERFACE read_prop_bound_content
     MODULE PROCEDURE read_prop_bound_cont
  END INTERFACE

  PUBLIC read_prop_recon_content
  PRIVATE read_prop_recon_cont
  INTERFACE read_prop_recon_content
     MODULE PROCEDURE read_prop_recon_cont
  END INTERFACE
  ! ---------------------------------------------------------------------------
  ! Public helpers
  !PRIVATE unit_propagator
  !PRIVATE unit_prop
  PUBLIC unit_propagator
  PUBLIC unit_prop
  INTERFACE unit_propagator
     MODULE PROCEDURE unit_prop
  END INTERFACE

  !PRIVATE filename_propagator
  !PRIVATE filename_prop
  PUBLIC filename_propagator
  PUBLIC filename_prop
  INTERFACE filename_propagator
     MODULE PROCEDURE filename_prop
  END INTERFACE

  ! ---------------------------------------------------------------------------
  ! Private routines for propagator handling
  PUBLIC construct_propagator                   ! Had to set to PUBLIC for parallel support
  PRIVATE construct_prop,construct_prop_1
  INTERFACE construct_propagator
     MODULE PROCEDURE construct_prop,construct_prop_1
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE destruct_propagator 
  PRIVATE destruct_prop
  INTERFACE destruct_propagator
     MODULE PROCEDURE destruct_prop
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PUBLIC destruct_all_propagators             ! Public for parallel support
  PRIVATE destruct_all_prop
  INTERFACE destruct_all_propagators
     MODULE PROCEDURE destruct_all_prop
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE deallocate_propagator_content
  PRIVATE deallocate_propagator_cont
  INTERFACE deallocate_propagator_content
     MODULE PROCEDURE deallocate_propagator_cont
  END INTERFACE
  ! ---------------------------------------------------------------------------
  !PUBLIC ASSIGNMENT(=)
  PUBLIC assign_propagator_content
  PRIVATE assign_propagator_cont,assign_propagator_cont_qe
  !INTERFACE ASSIGNMENT(=)
  INTERFACE assign_propagator_content
     MODULE PROCEDURE assign_propagator_cont,assign_propagator_cont_qe
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE diag_propagator_content
  PRIVATE diag_propagator_cont
  INTERFACE diag_propagator_content
     MODULE PROCEDURE diag_propagator_cont
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE diag_propagator_result
  PRIVATE diag_propagator_res
  INTERFACE diag_propagator_result
     MODULE PROCEDURE diag_propagator_res
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE diag_propagator_distrf
  PRIVATE diag_propagator_dis
  INTERFACE diag_propagator_distrf
     MODULE PROCEDURE diag_propagator_dis
  END INTERFACE
 
  ! ---------------------------------------------------------------------------
  ! Private interface to the ripple_solver and join_ripples subroutine
  PRIVATE ripple_solver_interface
  PRIVATE ripple_solver_int
  INTERFACE ripple_solver_interface
     MODULE PROCEDURE ripple_solver_int
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE plot_distrf_interface
  PRIVATE plot_distrf_int
  INTERFACE plot_distrf_interface
     MODULE PROCEDURE plot_distrf_int
  END INTERFACE
  ! ---------------------------------------------------------------------------
  PRIVATE join_ripples_interface
  PRIVATE join_ripples_int
  INTERFACE join_ripples_interface
     MODULE PROCEDURE join_ripples_int
  END INTERFACE
  ! ---------------------------------------------------------------------------

CONTAINS

  ! ---------------------------------------------------------------------------


  SUBROUTINE construct_prop(before_in)

    INTEGER, OPTIONAL :: before_in
    INTEGER           :: before

    IF (PRESENT(before_in)) THEN
       before = before_in
    ELSE
       before = 0
    END IF


    !
    ! Subroutine to setup a new propagator
    !
    ! At the moment prop_c has to be placed at the end and the
    ! new prop_c is associated with the new end of the linked list!
    ! 
    ! Allocate memory for a new node.
    ALLOCATE( prop_n )
    ! At the beginning of the loop root is not associated to some
    ! variable, so it has to be associated with the newnode.
    IF ( .NOT. ASSOCIATED( prop_r ) ) prop_r => prop_n
    ! If current is already associated its pointer next has to point
    ! towards the newly created node.
    ! The pointer prev of newnode has to point towards current.

    IF (before .EQ. 0) THEN
       IF ( ASSOCIATED( prop_c) ) THEN   
          IF ( ASSOCIATED( prop_c%next) ) THEN
             prop_n%next => prop_c%next
             prop_c%next%prev => prop_n
          end IF
          prop_c%next => prop_n
          prop_n%prev => prop_c
       END IF
    ELSE
       IF ( ASSOCIATED( prop_c) ) THEN   
          IF ( ASSOCIATED( prop_c%prev) ) THEN
             prop_n%prev => prop_c%prev
             prop_c%prev%next => prop_n
          end IF
          prop_c%prev => prop_n
          prop_n%next => prop_c
       END IF
    END IF
    ! Now the current node is associated with the newly created node.
    prop_c => prop_n
    ! The last node is associated with the current node.
    prop_l => prop_c
    ! When newnode is nullified, the association between newnode and the
    ! associated memory is deleted but the memory is not deallocated.
    ! At this moment the pointer current points towards this memory.
    NULLIFY( prop_n )
    ! indicated that it is not being used at the moment
    prop_c%nr_joined = -2
    ! a tag is added to the propagator
    propagator_tag_counter = propagator_tag_counter + 1
    prop_c%tag = propagator_tag_counter
    !
  END SUBROUTINE construct_prop

  ! ---------------------------------------------------------------------------
  SUBROUTINE construct_prop_1(prop)
    TYPE(propagator), POINTER            :: prop
    TYPE(propagator), POINTER            :: prop_new
    !
    ! Subroutine to setup a new propagator
    !
    ! At the moment prop_c has to be placed at the end and the
    ! new prop_c is associated with the new end of the linked list!
    ! 
    ! Allocate memory for a new node.
    ALLOCATE( prop_new )
    ! If current is already associated its pointer next has to point
    ! towards the newly created node.
    ! The pointer prev of newnode has to point towards current.

    IF ( ASSOCIATED( prop ) ) THEN   
       IF ( ASSOCIATED( prop%next) ) THEN
          prop_new%next => prop%next
          prop%next%prev => prop_new
       end IF
       prop%next => prop_new
       prop_new%prev => prop
    END IF
    ! Now the current node is associated with the newly created node.
    prop => prop_new
    ! indicated that it is not being used at the moment
    prop%nr_joined = -2
    NULLIFY( prop_new )
    !
  END SUBROUTINE construct_prop_1



  ! ---------------------------------------------------------------------------
  SUBROUTINE destruct_prop
    !
    ! Removes the current propagator prop_c 
    !
    ! Remove content
    CALL deallocate_propagator_content
    IF (.NOT. ASSOCIATED(prop_c%prev) .AND. ASSOCIATED(prop_c%next)) THEN
       ! Root is removed
       prop_r => prop_c%next
       prop_c%next%prev => NULL()
       DEALLOCATE( prop_c )
       prop_c => prop_r
    ELSEIF (ASSOCIATED(prop_c%prev) .AND. ASSOCIATED(prop_c%next)) THEN
       ! Middle is removed
       prop_n => prop_c
       prop_c%prev%next => prop_c%next
       prop_c%next%prev => prop_c%prev
       prop_c => prop_c%prev
       DEALLOCATE( prop_n )
       NULLIFY( prop_n )
    ELSEIF (ASSOCIATED(prop_c%prev) .AND. .NOT. ASSOCIATED(prop_c%next)) THEN
       ! Last is removed
       prop_l => prop_c%prev
       prop_c%prev%next => NULL()
       DEALLOCATE( prop_c )
       prop_c => prop_l
    ELSEIF (.NOT. ASSOCIATED(prop_c%prev) .AND. .NOT. ASSOCIATED(prop_c%next)) THEN
       ! Root and last are removed - nothing remains
       NULLIFY( prop_r )
       NULLIFY( prop_l )
       DEALLOCATE( prop_c )
       NULLIFY( prop_c )
    END IF
    !
  END SUBROUTINE destruct_prop

  ! ---------------------------------------------------------------------------
  SUBROUTINE destruct_all_prop
    !
    ! Subroutine to remove all propagators starting from the 
    ! last one (prop_l)
    prop_c => prop_l
    DO
       CALL destruct_propagator
       IF (.NOT. ASSOCIATED(prop_c)) EXIT
    END DO
    !
  END SUBROUTINE destruct_all_prop

  ! ---------------------------------------------------------------------------
  SUBROUTINE deallocate_propagator_cont()
    !
    ! Deallocates all parts of current propagator prop_c
    !
    ! Has to be changed if physical content of propagator changes!
    ! (see type declaration of propagator)
    !
    if (associated(prop_c)) then
       ! 2-D quantities
       IF (ALLOCATED(prop_c%p%amat_p_p)) DEALLOCATE(prop_c%p%amat_p_p)
       IF (ALLOCATED(prop_c%p%amat_m_m)) DEALLOCATE(prop_c%p%amat_m_m)
       IF (ALLOCATED(prop_c%p%amat_p_m)) DEALLOCATE(prop_c%p%amat_p_m)
       IF (ALLOCATED(prop_c%p%amat_m_p)) DEALLOCATE(prop_c%p%amat_m_p)
       !
       IF (ALLOCATED(prop_c%p%cmat)) DEALLOCATE(prop_c%p%cmat)
       IF (ALLOCATED(prop_c%p%source_p)) DEALLOCATE(prop_c%p%source_p)        !<-in
       IF (ALLOCATED(prop_c%p%source_m)) DEALLOCATE(prop_c%p%source_m)        !<-in
       
       IF (ALLOCATED(prop_c%p%flux_p))   DEALLOCATE(prop_c%p%flux_p)
       IF (ALLOCATED(prop_c%p%flux_m))   DEALLOCATE(prop_c%p%flux_m)
       
       IF (ALLOCATED(prop_c%p%qflux))   DEALLOCATE(prop_c%p%qflux)            !<-in
       
       ! 1-D quantities                                                       !<-in
       IF (ALLOCATED(prop_c%p%eta_l))   DEALLOCATE(prop_c%p%eta_l)
       IF (ALLOCATED(prop_c%p%eta_r))   DEALLOCATE(prop_c%p%eta_r)
       
       ! working array
       IF (ALLOCATED(prop_c%p%w)) DEALLOCATE(prop_c%p%w)
       ! y-vector (magnetics)
       IF (ALLOCATED(prop_c%y)) DEALLOCATE(prop_c%y)
       
       ! binarysplit
       CALL deconstruct_binarysplit(prop_c%eta_bs_l)
       CALL deconstruct_binarysplit(prop_c%eta_bs_r)
    end if
    !
  END SUBROUTINE deallocate_propagator_cont

  ! ---------------------------------------------------------------------------
  SUBROUTINE assign_propagator_cont(n,o)
    TYPE(propagator), POINTER  :: n
    TYPE(propagator), POINTER  :: o
    
    n%nr_joined             = o%nr_joined
    n%bin_split_mode        = o%bin_split_mode
    IF (o%bin_split_mode .EQ. 1) THEN
       n%eta_bs_l              = o%eta_bs_l
       n%eta_bs_r              = o%eta_bs_r
    END IF
    n%fieldpropagator_tag_s = o%fieldpropagator_tag_s
    n%fieldpropagator_tag_e = o%fieldpropagator_tag_e
    n%fieldperiod_tag_s     = o%fieldperiod_tag_s
    n%fieldperiod_tag_e     = o%fieldperiod_tag_e
    n%phi_l                 = o%phi_l
    n%phi_r                 = o%phi_r

    IF(ALLOCATED(o%y)) THEN
       if (allocated(n%y)) deallocate(n%y)
       ALLOCATE(n%y(LBOUND(o%y,1):UBOUND(o%y,1)))
       n%y                  = o%y
    END IF
    CALL assign_propagator_content(n%p,o%p)
  END SUBROUTINE assign_propagator_cont

  SUBROUTINE assign_propagator_cont_qe(pn,po)
    TYPE(prop_qe), INTENT(inout) :: pn
    TYPE(prop_qe), INTENT(in)    :: po

    pn%npart          = po%npart
    pn%npass_l        = po%npass_l
    pn%npass_r        = po%npass_r
    pn%nvelocity       = po%nvelocity                                        !<-in

    IF (ALLOCATED(po%qflux)) THEN                                          !<-in
       if (allocated(pn%qflux)) deallocate(pn%qflux)
       ALLOCATE(pn%qflux(SIZE(po%qflux,1),SIZE(po%qflux,2)))               !<-in
       pn%qflux    = po%qflux                                              !<-in
    END IF                                                                 !<-in


    pn%eta_boundary_l = po%eta_boundary_l
    pn%eta_boundary_r = po%eta_boundary_r

    IF (ALLOCATED(po%amat_p_p)) THEN
       if (allocated(pn%amat_p_p)) deallocate(pn%amat_p_p)
       ALLOCATE(pn%amat_p_p(SIZE(po%amat_p_p,1),SIZE(po%amat_p_p,2)))
       pn%amat_p_p    = po%amat_p_p
    END IF
    IF (ALLOCATED(po%amat_m_m)) THEN
       if (allocated(pn%amat_m_m)) deallocate(pn%amat_m_m)
       ALLOCATE(pn%amat_m_m(SIZE(po%amat_m_m,1),SIZE(po%amat_m_m,2)))
       pn%amat_m_m    = po%amat_m_m
    END IF
    IF (ALLOCATED(po%amat_p_m)) THEN
       if (allocated(pn%amat_p_m)) deallocate(pn%amat_p_m)
       ALLOCATE(pn%amat_p_m(SIZE(po%amat_p_m,1),SIZE(po%amat_p_m,2)))
       pn%amat_p_m    = po%amat_p_m
    END IF
    IF (ALLOCATED(po%amat_m_p)) THEN
       if (allocated(pn%amat_m_p)) deallocate(pn%amat_m_p)
       ALLOCATE(pn%amat_m_p(SIZE(po%amat_m_p,1),SIZE(po%amat_m_p,2)))
       pn%amat_m_p    = po%amat_m_p
    END IF

    IF (ALLOCATED(po%cmat)) THEN
       if (allocated(pn%cmat)) deallocate(pn%cmat)
       ALLOCATE(pn%cmat(SIZE(po%cmat,1),SIZE(po%cmat,2)))
       pn%cmat        = po%cmat
    END IF
    
    IF (ALLOCATED(po%w)) THEN
       if (allocated(pn%w)) deallocate(pn%w)
       ALLOCATE(pn%w(SIZE(po%w,1),SIZE(po%w,2)))
       pn%w           = po%w
    END IF
    
    IF (ALLOCATED(po%source_p)) THEN                                       !<-in
       if (allocated(pn%source_p)) deallocate(pn%source_p)
       ALLOCATE(pn%source_p(SIZE(po%source_p,1),SIZE(po%source_p,2)))      !<-in
       pn%source_p  = po%source_p                                          !<-in
    END IF                                                                 !<-in
    IF (ALLOCATED(po%source_m)) THEN                                       !<-in
       if (allocated(pn%source_m)) deallocate(pn%source_m)
       ALLOCATE(pn%source_m(SIZE(po%source_m,1),SIZE(po%source_m,2)))      !<-in
       pn%source_m  = po%source_m                                          !<-in
    END IF                                                                 !<-in
    
    IF (ALLOCATED(po%flux_p)) THEN
       if (allocated(pn%flux_p)) deallocate(pn%flux_p)
       ALLOCATE(pn%flux_p(SIZE(po%flux_p,1),SIZE(po%flux_p,2)))            !<-in
       pn%flux_p     = po%flux_p
    END IF
    IF (ALLOCATED(po%flux_m)) THEN
       if (allocated(pn%flux_m)) deallocate(pn%flux_m)
       ALLOCATE(pn%flux_m(SIZE(po%flux_m,1),SIZE(po%flux_m,2)))            !<-in
       pn%flux_m     = po%flux_m
    END IF

    IF (ALLOCATED(po%eta_l)) THEN
       if (allocated(pn%eta_l)) deallocate(pn%eta_l)
       ALLOCATE(pn%eta_l(LBOUND(po%eta_l,1):UBOUND(po%eta_l,1)))
       pn%eta_l      = po%eta_l
    END IF
    IF (ALLOCATED(po%eta_r)) THEN
       if (allocated(pn%eta_r)) deallocate(pn%eta_r)
       ALLOCATE(pn%eta_r(LBOUND(po%eta_r,1):UBOUND(po%eta_r,1)))
       pn%eta_r      = po%eta_r
    END IF


  END SUBROUTINE assign_propagator_cont_qe

  ! ---------------------------------------------------------------------------
  SUBROUTINE diag_propagator_cont()
    !
    USE magnetics_mod
    USE device_mod
    ! physical diagnostic
    ! all quantities have to be taken from prop_a
    INTEGER :: uw
    INTEGER :: i,proptag
    LOGICAL :: opened
    CHARACTER(len=10) :: cname,ctag_s,ctag_e
    CHARACTER(len=22) :: cadd,tags

    TYPE(fieldpropagator_struct), POINTER :: plotpropagator

#if !defined(MPI_SUPPORT)
    
    ! find free unit
    uw = 100
    DO
       INQUIRE(unit=uw,opened=opened)
       IF(.NOT. opened) EXIT
       uw = uw + 100
    END DO

    WRITE(ctag_s,*) prop_a%fieldpropagator_tag_s
    WRITE(ctag_e,*) prop_a%fieldpropagator_tag_e
    IF (prop_a%fieldpropagator_tag_s .EQ. prop_a%fieldpropagator_tag_e) THEN
       cadd = '_'//TRIM(ADJUSTL(ctag_s))//'.dat'
    ELSE
       cadd = '_'//TRIM(ADJUSTL(ctag_s))//'_'//TRIM(ADJUSTL(ctag_e))//'.dat'
    END IF
    tags = cadd

    IF (prop_overwrite .EQ. 1) THEN
       cadd = '.dat'
    END IF
    
    cname = 'amat_p_p'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    DO i = 1,SIZE(prop_a%p%amat_p_p,1)
       WRITE(uw,*) prop_a%p%amat_p_p(i,:)
    END DO
    CLOSE(uw)

    cname = 'amat_m_m'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    DO i = 1,SIZE(prop_a%p%amat_m_m,1)
       WRITE(uw,*) prop_a%p%amat_m_m(i,:)
    END DO
    CLOSE(uw)

    cname = 'amat_p_m'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    DO i = 1,SIZE(prop_a%p%amat_p_m,1)
       WRITE(uw,*) prop_a%p%amat_p_m(i,:)
    END DO
    CLOSE(uw)

    cname = 'amat_m_p'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    DO i = 1,SIZE(prop_a%p%amat_m_p,1)
       WRITE(uw,*) prop_a%p%amat_m_p(i,:)
    END DO
    CLOSE(uw)

    cname = 'source_p_g'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%source_p_g
    WRITE(uw,*) prop_a%p%source_p(:,1)                                     !<-in
    CLOSE(uw)
    cname = 'source_p_e'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%source_p_e
    WRITE(uw,*) prop_a%p%source_p(:,2)                                     !<-in
    CLOSE(uw)
    cname = 'source_m_g'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%source_m_g
    WRITE(uw,*) prop_a%p%source_m(:,1)                                     !<-in
    CLOSE(uw)
    cname = 'source_m_e'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%source_m_e
    WRITE(uw,*) prop_a%p%source_m(:,2)                                     !<-in
    CLOSE(uw)

    cname = 'flux_p'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%flux_p
    WRITE(uw,*) prop_a%p%flux_p(1,:)                                       !<-in
    CLOSE(uw)    
    cname = 'flux_m'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%flux_m
    WRITE(uw,*) prop_a%p%flux_m(1,:)                                       !<-in
    CLOSE(uw)
    cname = 'curr_p'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%curr_p
    WRITE(uw,*) prop_a%p%flux_p(2,:)                                       !<-in
    CLOSE(uw)    
    cname = 'curr_m'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
!->out    WRITE(uw,*) prop_a%p%curr_m
    WRITE(uw,*) prop_a%p%flux_m(2,:)                                       !<-in
    CLOSE(uw)
    
    cname = 'eta'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    IF (prop_a%bin_split_mode .EQ. 1) THEN
       WRITE(uw,*) prop_a%p%eta_boundary_l,    &
            prop_a%p%eta_boundary_r,           &
            prop_a%eta_bs_l%x(1:)
    ELSE
       WRITE(uw,*) prop_a%p%eta_boundary_l,    &
            prop_a%p%eta_boundary_r,           &
            fieldpropagator%ch_act%eta(1:)
    END IF
    CLOSE(uw)
    
    ! summary
    cname = 'summary'
    OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))
    WRITE(uw,*) 'bin_split_mode  ',prop_a%bin_split_mode
    WRITE(uw,*) 'tag_start       ',prop_a%fieldpropagator_tag_s
    WRITE(uw,*) 'tag_end         ',prop_a%fieldpropagator_tag_e
    WRITE(uw,*) 'tag_period_start',prop_a%fieldperiod_tag_s
    WRITE(uw,*) 'tag_period_end  ',prop_a%fieldperiod_tag_e
    WRITE(uw,*) ' '
    WRITE(uw,*) 'npart           ',prop_a%p%npart
    WRITE(uw,*) 'npass_l         ',prop_a%p%npass_l
    WRITE(uw,*) 'npass_r         ',prop_a%p%npass_r
!->out    WRITE(uw,*) 'npart_halfband  ',prop_a%p%npart_halfband
    WRITE(uw,*) 'nvelocity        ',prop_a%p%nvelocity                       !<-in
!->out    WRITE(uw,*) 'qflux_g         ',prop_a%p%qflux_g
!->out    WRITE(uw,*) 'qflux_e         ',prop_a%p%qflux_e
!->out    WRITE(uw,*) 'qcurr_g         ',prop_a%p%qcurr_g
!->out    WRITE(uw,*) 'qcurr_e         ',prop_a%p%qcurr_e
    WRITE(uw,*) 'qflux_g         ',prop_a%p%qflux(1,1)                     !<-in
    WRITE(uw,*) 'qflux_e         ',prop_a%p%qflux(1,2)                     !<-in
    WRITE(uw,*) 'qcurr_g         ',prop_a%p%qflux(2,1)                     !<-in
    WRITE(uw,*) 'qcurr_e         ',prop_a%p%qflux(2,2)                     !<-in
    WRITE(uw,*) 'eta_boundary_l  ',prop_a%p%eta_boundary_l
    WRITE(uw,*) 'eta_boundary_r  ',prop_a%p%eta_boundary_r
    CLOSE(uw)
    
    PRINT *, 'Physical Output written on files *'//TRIM(ADJUSTL(cadd))
    PRINT *, 'Involved propagator tags:         '  &
         //TRIM(ADJUSTL(ctag_s))//' '//TRIM(ADJUSTL(ctag_e))

    ! output only for original propagators (not joined)
    IF (prop_a%fieldpropagator_tag_s .EQ. prop_a%fieldpropagator_tag_e) THEN
       proptag = prop_a%fieldpropagator_tag_s
       CALL info_magnetics(fieldpropagator)
       cname = 'propm'
       OPEN(unit=uw,file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)))

       plotpropagator => fieldpropagator
       CALL plot_magnetics(plotpropagator,proptag,proptag,  &
            TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd)) &
            )
        
       cname = 'etam'
       OPEN(unit=uw,status='replace',                       &
            file=TRIM(ADJUSTL(cname))//TRIM(ADJUSTL(cadd))  &
            )
       DO i = 1,UBOUND(fieldpropagator%ch_act%eta,1)
          WRITE(uw,'(3i6,1000(1x,e15.8))')              &
               i,fieldpropagator%phi_eta_ind(i,1),      &
               fieldpropagator%phi_eta_ind(i,2),        &
               fieldpropagator%ch_act%eta(i),           &
               1.0_dp - fieldpropagator%ch_act%eta(i) * & 
               fieldpropagator%mdata%bhat(              &
               fieldpropagator%phi_eta_ind(i,1)         &
               ),                                       &
               1.0_dp - fieldpropagator%ch_act%eta(i) * &
               fieldpropagator%mdata%bhat(              &
               fieldpropagator%phi_eta_ind(i,2)         &
               )
       END DO
       CLOSE(unit=uw)
       
    END IF
    
    !PAUSE
#endif

  END SUBROUTINE diag_propagator_cont

  SUBROUTINE diag_propagator_res(iend)
    ! writes out eps_eff and related stuff
    ! ATTENTION hxeta does not exist any more

    USE device_mod
    USE collisionality_mod, ONLY : collpar, conl_over_mfp, &
         isw_lorentz, isw_integral, isw_energy, isw_axisymm, y_axi_averages
    USE rkstep_mod, ONLY : asource,anumm,ailmm,lag,leg
    USE collop, ONLY : z_eff
    USE mag_interface_mod, ONLY : magnetic_device,mag_magfield
    
    INTEGER, INTENT(in) :: iend

    LOGICAL :: opened
    INTEGER :: uw

    REAL(kind=dp) :: g_bs                                                 !<-GBS

    REAL(kind=dp) :: transport_factor
    REAL(kind=dp) :: qflux_g,qcurr_g
    REAL(kind=dp) :: qflux_e,qcurr_e
    REAL(kind=dp) :: dmono_over_dplateau,epseff3_2
    REAL(kind=dp) :: alambda_b,alambda_bb
    REAL(kind=dp) :: gamma_E
    REAL(kind=dp) :: aiota_loc,rt0
    REAL(kind=dp) :: phi

    REAL(kind=dp), ALLOCATABLE :: y(:)

    ! Declarations for final output
    REAL(kind=dp) :: gamma_fco(3,3)
    real(kind=dp), allocatable :: gamma_out(:,:)
    REAL(kind=dp) :: beta_out(3)
    REAL(kind=dp) :: avnabpsi,avbhat2,dl1obhat

    INTEGER, PARAMETER, DIMENSION(3) :: ind_map = (/1,3,2/)
    INTEGER :: i, i_p, j, j_p
    integer :: full_version

    character(len=100) :: cname,ctag_s,ctag_e
    character(len=100) :: cadd,tags

    !**********************************************************
    ! For D11_ov_Dpl
    !**********************************************************
    real(kind=dp) :: fac1, fac2, D11_NA_Dpl
    
    allocate(gamma_out(3,3))
   
    ! taken from Sergei
!->out    qflux_g = prop_a%p%qflux_g
!->out    qcurr_g = prop_a%p%qcurr_g
!->out    qflux_e = prop_a%p%qflux_e
!->out    qcurr_e = prop_a%p%qcurr_e
    qflux_g = prop_a%p%qflux(1,1)                                          !<-in
    qcurr_g = prop_a%p%qflux(2,1)                                          !<-in
    qflux_e = prop_a%p%qflux(1,2)                                          !<-in
    qcurr_e = prop_a%p%qflux(2,2)                                          !<-in
    if ( (magnetic_device .EQ. 0 .and. isw_axisymm .eq. 1) .or. mag_magfield .eq. 0 ) then
       ALLOCATE(y(SIZE(y_axi_averages,1)))
       y = y_axi_averages
    else
       ALLOCATE(y(SIZE(prop_a%y,1)))
       y = prop_a%y
    end if
    aiota_loc = surface%aiota
    rt0 = device%r0
    phi = prop_a%phi_r

!!$    PRINT *, 'y ',y
!!$    PRINT *, 'aiota_loc ',aiota_loc 
!!$    PRINT *, 'rt0 ',rt0
!!$    PRINT *, 'phi ',phi
!!$    PRINT *, 'qflux_g ',qflux_g
    transport_factor = qflux_g*y(6)*(y(14)/(y(7)*y(13)))**2
!!$    PRINT *, 'transport_factor ',transport_factor
!!$    PAUSE
    dmono_over_dplateau=-2.d0*SQRT(2.d0)/pi*rt0*aiota_loc*transport_factor

    epseff3_2=-(9.d0*pi/(16.d0*SQRT(2.d0)))*collpar*rt0**2     &
         *transport_factor 

    alambda_b=-0.75d0 * qcurr_g *y(6)/(y(7)*y(9))
    alambda_bb=alambda_b * y(9) / y(6)
    g_bs=2.d0*qcurr_g/(y(7)*(collpar*qcurr_e/y(9)-8.d0/3.d0))             !<-GBS
    ! gamma_E from the Spitzer-Haerm paper 
    ! to get the values there, the result has to be multiplied by Zeff
    ! sigma / sigma_lorentz(zeff=1)
!    gamma_E = (3.d0*SQRT(pi)*qcurr_e*collpar/(32.d0*y(9)))  !***change19.09.07
    gamma_E = (3.d0*pi*qcurr_e*collpar/(32.d0*y(9)))
    !PRINT *, 'I am in diag_propagator_result'
    !PRINT *, 'iota = ',aiota_loc, 'qflux_g = ',qflux_g,' qcurr_g = ',qcurr_g
    
    ! find free unit
    uw = 100
    DO
       INQUIRE(unit=uw,opened=opened)
       IF(.NOT. opened) EXIT
       uw = uw + 100
    END DO

    !**********************************************************
    ! New method to write evolve in parallel mode
    !**********************************************************
    write(ctag_s,*) prop_a%fieldpropagator_tag_s
    write(ctag_e,*) prop_a%fieldpropagator_tag_e
    !write(ctag_s,*) prop_c%tag
    !write(ctag_e,*) prop_c%tag
    
    !if (prop_a%fieldpropagator_tag_s .eq. prop_a%fieldpropagator_tag_e) then
    !   cadd = '_'//trim(adjustl(ctag_s))
    !else
    cadd = '_'//trim(adjustl(ctag_s))//'_'//trim(adjustl(ctag_e))
    !end if

    if (prop_fileformat .eq. 1) then
       if (prop_write .lt. 0) then
          call h5_create('evolve' // trim(adjustl(cadd)) // '.h5', h5id)

          call h5_add(h5id, 'tag_s', prop_a%fieldpropagator_tag_s)
          call h5_add(h5id, 'tag_e', prop_a%fieldpropagator_tag_e)

          call h5_add(h5id, 'phi', phi)
          call h5_add(h5id, 'y', y, lbound(y), ubound(y))
          call h5_add(h5id, 'aiota_loc', aiota_loc)
          call h5_add(h5id, 'dmono_over_dplateau', dmono_over_dplateau)
          call h5_add(h5id, 'epseff3_2', epseff3_2)
          call h5_add(h5id, 'alambda_b', alambda_b)
          call h5_add(h5id, 'qflux_g', qflux_g)
          call h5_add(h5id, 'qflux_e', qflux_e)
          call h5_add(h5id, 'qcurr_g', qcurr_g)
          call h5_add(h5id, 'qcurr_e', qcurr_e)
          call h5_add(h5id, 'alambda_bb', alambda_bb)
          call h5_add(h5id, 'g_bs', g_bs)
          call h5_add(h5id, 'r0', device%r0)
          call h5_add(h5id, 'bmod0', surface%bmod0)

          call h5_close(h5id)
       end if
    else
       open(uw,file='evolve' // trim(adjustl(cadd)) // '.dat', status='replace')
       write (uw,'(1000(1x,e18.5))')                                   &
            (phi),(y(1:2)),(aiota_loc),                    &
            (dmono_over_dplateau),(epseff3_2),(alambda_b), &
            (qflux_g),(qflux_e),(qcurr_g),(qcurr_e),    &
            (alambda_bb),(gamma_E), &
            (g_bs),    &                                              !<-GBS
            (device%r0),(surface%bmod0)  !, &
       !y(6),y(7),y(9),y(13),y(14)
       ! WRITE (uw,*)                                   &
       !     y
!!$         WRITE (uw,'(1000(1x,e12.5))')                                   &
!!$         REAL(phi),REAL(y(1:2)),REAL(aiota_loc),                    &
!!$         REAL(dmono_over_dplateau),REAL(epseff3_2),REAL(alambda_b), &
!!$         REAL(qflux_g),REAL(qflux_e),REAL(qcurr_g),REAL(qcurr_e)    &
!!$         ,REAL(alambda_bb),REAL(3.d0*SQRT(pi)*qcurr_e*collpar/(32.d0*y(9)))*1.d0 &
!!$         ,REAL(g_bs)    &                                              !<-GBS
!!$         ,REAL(device%r0),REAL(surface%bmod0)
       close(uw)
    end if

    

    ! Final output
    IF ( iend .EQ. 1) THEN
       full_version = 2
       avnabpsi = y(7) / y(6)
       avbhat2 = y(9) / y(6)
       dl1obhat = y(6)
!       beta_out = (/ 1.0_dp/avnabpsi, 1.0_dp/avnabpsi, 1.0_dp /) ***change: 19.09.07
       beta_out = (/ y(14)/y(13)/avnabpsi, y(14)/y(13)/avnabpsi, y(13)/y(14) /)
    
       DO i = 1,3
          i_p = ind_map(i)
          DO j = 1,3
             j_p = ind_map(j)
!             gamma_fco(i,j) = prop_a%p%qflux(i_p,j_p) / y(9)!***change: 19.09.07
             gamma_fco(i,j) = - prop_a%p%qflux(i_p,j_p) / y(6)
             gamma_out(i,j) = gamma_fco(i,j) * beta_out(i) * beta_out(j)
          END DO
       END DO

       if (prop_fileformat .eq. 1) then

          ! Write to HDF5 file
          call h5_create('fulltransp.h5', h5id, 1)

          call h5_add(h5id, 'full_version', full_version)
          call h5_add(h5id, 'isw_lorentz', isw_lorentz)
          call h5_add(h5id, 'isw_integral', isw_integral)
          call h5_add(h5id,  'isw_energy', isw_energy)         
          call h5_add(h5id, 'lag', lag, 'Degree of the Laguerre Polynomials')
          call h5_add(h5id, 'leg', leg, 'Degree of the Legendre Polynomials')
          call h5_add(h5id, 'collpar', collpar)
          call h5_add(h5id, 'conl_over_mfp', conl_over_mfp)
          call h5_add(h5id, 'z_eff', z_eff)
          call h5_add(h5id, 'avnabpsi', avnabpsi)
          call h5_add(h5id, 'avbhat2', avbhat2)
          call h5_add(h5id, 'dl1obhat', dl1obhat)
          call h5_add(h5id, 'gamma_out', gamma_out, lbound(gamma_out), ubound(gamma_out))

          call h5_close(h5id)
          
       else

          ! Write to ASCII file
          OPEN(uw,file='fulltransp.dat',status='replace')
          WRITE (uw,'(6(1x,i4),1000(1x,e18.5))')  &
               full_version, &
               isw_lorentz, isw_integral, isw_energy, lag, leg, &
               conl_over_mfp, collpar, z_eff, &
               avnabpsi, avbhat2, dl1obhat, &
               gamma_out
          CLOSE(uw)
          
       end if

       if (prop_fileformat .eq. 1) then
          
          ! normalization factor from plateau coefficient
          fac1=16.0_dp*rt0*aiota_loc/PI
          ! normalization factor from gamma matrices
          fac2= - beta_out(1) * beta_out(1) / y(6)
          !PRINT *,fac1,fac2
          ! convert indices for the gamma matrices according 
          ! to the paper Kernbichler(2008)
          i_p = ind_map(1)
          j_p = ind_map(1)
          D11_NA_Dpl=fac1*fac2*prop_a%p%qflux(i_p,j_p)

          
          ! Write to HDF5 file
          call h5_create('efinal.h5', h5id, 1)

          call h5_add(h5id, 'phi', phi)
          call h5_add(h5id, 'aiota_loc', aiota_loc)
          call h5_add(h5id, 'dmono_over_dplateau', dmono_over_dplateau)
          call h5_add(h5id, 'epseff3_2', epseff3_2)
          call h5_add(h5id, 'alambda_b', alambda_b)
          call h5_add(h5id, 'qflux_g', qflux_g)
          call h5_add(h5id, 'qflux_e', qflux_e)
          call h5_add(h5id, 'qcurr_g', qcurr_g)
          call h5_add(h5id, 'qcurr_e', qcurr_e)
          call h5_add(h5id, 'alambda_bb', alambda_bb)
          call h5_add(h5id, 'gamma_E',gamma_E )
          call h5_add(h5id, 'g_bs', g_bs)
          call h5_add(h5id, 'r0', device%r0)
          call h5_add(h5id, 'bmod0', surface%bmod0)
          call h5_add(h5id, 'y', y, lbound(y), ubound(y))

          !**********************************************************
          ! D11_ov_Dpl
          !**********************************************************
          call h5_add(h5id, 'D11_ov_Dpl', D11_NA_Dpl)
          
          call h5_close(h5id)      

       else

          ! Write to ASCII file
          OPEN(uw,file='efinal.dat',status='replace')
          WRITE (uw,'(1000(1x,e18.5))')                                   &
               (phi),(y(1:2)),(aiota_loc),                    &
               (dmono_over_dplateau),(epseff3_2),(alambda_b), &
               (qflux_g),(qflux_e),(qcurr_g),(qcurr_e),    &
               (alambda_bb),(gamma_E), &
               (g_bs),    &
               (device%r0),(surface%bmod0), &
               y(6),y(7),y(9),y(13),y(14)
          CLOSE(uw)
          
       end if

    END IF

    deallocate(gamma_out)
    deallocate(y)
  END SUBROUTINE diag_propagator_res
  ! ---------------------------------------------------------------------------
  SUBROUTINE diag_propagator_dis

    CALL plot_distrf_interface

  END SUBROUTINE diag_propagator_dis
  ! ---------------------------------------------------------------------------

  ! --- MPI SUPPORT ---
  
  SUBROUTINE propagator_solver_all(proptag_start,proptag_end, & 
       bin_split_mode,eta_ori, parallelmode)
    USE device_mod
    USE magnetics_mod

    INTEGER, INTENT(in) :: proptag_start,proptag_end
    INTEGER, INTENT(in) :: bin_split_mode
    REAL(kind=dp), ALLOCATABLE :: eta_ori(:)

    ! This switch is true if the function is called from a parallel workunit
    logical :: parallelmode

    integer :: iend,iendperiod
    integer :: rippletag,proptag
    integer :: clear_old_ripple,rippletag_old
    integer :: ierr_solv,ierr_join
    integer :: period_count
    integer :: iend_sol

    ! This switch was used to trigger a fake parallelization (all happens on one client)
    ! process during development of the parallel NEO-2.
    ! However, it is not used anymore by the parallel NEO-2, but will stay in the code
    ! in an uncommented form for studies of the parallelization.
    integer :: fakeparallel = 0 

    if (fakeparallel .eq. 0) then 
       ! this is a version of the code which runs in the usual way
       ! all joining is done in propagator_solver
       ! see below for the case 1, which is divided into pieces
       ! with several fieldperiods

       ! go to the first propagator which is wanted
       fieldperiod => fieldline%ch_fir 
       fieldpropagator => fieldperiod%ch_fir
       DO WHILE (fieldpropagator%tag .LT. proptag_start)
          IF (.NOT. ASSOCIATED(fieldpropagator%next)) EXIT
          fieldpropagator => fieldpropagator%next
       END DO
       fieldripple => fieldpropagator%ch_act
       iend = 0
       iend_sol = 0
       iendperiod = 0
       rippletag_old = 0

       allprops_comp_np: DO
          ! information about propagator
          CALL info_magnetics(fieldpropagator)
          CALL info_magnetics(fieldpropagator%parent)
          
          fieldperiod => fieldpropagator%parent
          fieldripple => fieldpropagator%ch_act
          rippletag = fieldripple%tag
          proptag = fieldpropagator%tag
          !WRITE(c_propagator_tag,*) proptag
          !WRITE(c_ripple_tag,*) rippletag
          !WRITE(c_period_tag,*) fieldperiod%tag
          
          clear_old_ripple = 0
          newripple_comp_np: IF (rippletag .NE. rippletag_old) THEN
             clear_old_ripple = 1
             rippletag_old = rippletag
             fieldripple%bin_split_mode = bin_split_mode
          END IF newripple_comp_np
          
          IF (fieldpropagator%tag .EQ. proptag_end) THEN 
             iend = 1
             iendperiod = 1
          ELSE
             IF (ASSOCIATED(fieldpropagator%next)) THEN
                IF (fieldpropagator%parent%tag .NE. fieldpropagator%next%parent%tag) THEN 
                   iendperiod = 1
                ELSE
                   iendperiod = 0
                END IF
             ELSE
                iendperiod = 1
             END IF
          END IF
          
          if (iendperiod .eq. 1) period_count = period_count + 1 

          ! This is special if the function is called from a parallel workunit
          if (.not. parallelMode) iend_sol = iend
          
          CALL propagator_solver(                                  &
               iend_sol,iendperiod,bin_split_mode,eta_ori,             &
               ierr_solv,ierr_join                                 &
               )
          ! go to the next propagator or exit
          IF (fieldpropagator%tag .EQ. proptag_end) EXIT allprops_comp_np
          IF (.NOT.(ASSOCIATED(fieldpropagator%next))) THEN
             fieldpropagator => fieldline%ch_fir%ch_fir
          ELSE
             IF (fieldpropagator%next%tag .LE. fieldline%ch_las%ch_las%tag) THEN
                fieldpropagator => fieldpropagator%next
             ELSE
                fieldpropagator => fieldline%ch_fir%ch_fir
             END IF
          END IF
       END DO allprops_comp_np

       ! deallocate
       propagator_tag_counter = 0
       prop_count_call = 0
       !call destruct_all_propagators
          
    elseif (fakeparallel .eq. 1) then ! fake parallelization
       write (*,*) 'This parallel mode is the fake parallelization on one client.'
       write (*,*) 'This part of the code is outsourced to the corresponding workunits.'
       write (*,*) 'However it can be used to study the parallelization process in the code. Stopping propgram.'
       stop
!!$       ! here the fieldline is divided into parts, which consist
!!$       ! of several fieldperiods (period_limit)
!!$       ! within this parts everything is handled as before and
!!$       ! propagator_solver is responsible for solving a propagator,
!!$       ! joining within a fieldperiod and joining of fieldperiods
!!$       
!!$       ! go to the first propagator which is wanted
!!$       fieldperiod => fieldline%ch_fir 
!!$       fieldpropagator => fieldperiod%ch_fir
!!$       DO WHILE (fieldpropagator%tag .LT. proptag_start)
!!$          IF (.NOT. ASSOCIATED(fieldpropagator%next)) EXIT
!!$          fieldpropagator => fieldpropagator%next
!!$       END DO
!!$       fieldripple => fieldpropagator%ch_act
!!$       iend = 0
!!$       iendperiod = 0
!!$       rippletag_old = 0
!!$       ! now the fieldpropagator points to the fieldpropagator
!!$       ! with the tag proptag_start
!!$
!!$       ! we now go through groups of fieldperiods. the number of
!!$       ! fieldperiods in group is period_limit (or less in the last one).
!!$       ! these could be viewed as a group which is handled by a client.
!!$       ! therefore client_count is used as a variable.
!!$       !
!!$       ! this can be viewed as an idea for parallelization. most of the necessary 
!!$       ! elements are here. ne can see how to join two groups of fieldperiods.
!!$       ! of course, a send and receive routine has to be programmed, because here
!!$       ! it is only done through copying within the same client. 
!!$       allperiods_p: do while (iend .eq. 0) 
!!$          client_count = client_count + 1
!!$          period_count = 0 ! counts the periods in a group of periods
!!$
!!$          ! we now go through all propagators in this group of fieldperiods
!!$          allprops_comp_p: DO
!!$             ! information about propagator is written out to the screen
!!$             CALL info_magnetics(fieldpropagator)
!!$             CALL info_magnetics(fieldpropagator%parent)
!!$             
!!$             ! fielperiod and fieldripple which belong the actual fieldpropagator
!!$             fieldperiod => fieldpropagator%parent
!!$             fieldripple => fieldpropagator%ch_act
!!$             ! tags
!!$             rippletag = fieldripple%tag
!!$             proptag = fieldpropagator%tag
!!$             
!!$             ! here it is determined whether the end is reached (iend=1) or
!!$             ! whether the end of a fieldperiod is reached (iendperiod=1) 
!!$             IF (fieldpropagator%tag .EQ. proptag_end) THEN 
!!$                iend = 1
!!$                iendperiod = 1
!!$             ELSE
!!$                IF (ASSOCIATED(fieldpropagator%next)) THEN
!!$                   IF (fieldpropagator%parent%tag .NE. fieldpropagator%next%parent%tag) THEN 
!!$                      iendperiod = 1
!!$                   ELSE
!!$                      iendperiod = 0
!!$                   END IF
!!$                ELSE
!!$                   iendperiod = 1
!!$                END IF
!!$             END IF
!!$             
!!$             ! at the end of a fieldperiod period_count is increased
!!$             if (iendperiod .eq. 1) period_count = period_count + 1 
!!$             
!!$             ! propagator_solver now solves for one propagator, joins
!!$             ! within periods and joins periods within a group of periods
!!$             ! iend_sol=0 is passed to solver instead of iend. with this
!!$             ! the final ends will not be joined
!!$             iend_sol = 0
!!$
!!$             CALL propagator_solver(                                  &
!!$                  iend_sol,iendperiod,bin_split_mode,eta_ori,         &
!!$                  ierr_solv,ierr_join                                 &
!!$                  )
!!$
!!$             
!!$             ! go to the next propagator or exit
!!$             IF (fieldpropagator%tag .EQ. proptag_end) EXIT allprops_comp_p
!!$             IF (.NOT.(ASSOCIATED(fieldpropagator%next))) THEN
!!$                fieldpropagator => fieldline%ch_fir%ch_fir
!!$             ELSE
!!$                IF (fieldpropagator%next%tag .LE. fieldline%ch_las%ch_las%tag) THEN
!!$                   fieldpropagator => fieldpropagator%next
!!$                ELSE
!!$                   fieldpropagator => fieldline%ch_fir%ch_fir
!!$                END IF
!!$             END IF
!!$             ! exit this loop when the period_limit is reached
!!$             IF (period_count .EQ. period_limit) EXIT allprops_comp_p
!!$          END DO allprops_comp_p
!!$          ! the joined result now for the group of fieldperiods is available in
!!$          ! prop_c%prev
!!$
!!$           !call store_propagator()
!!$
!!$          if (client_count .eq. 1) then
!!$
!!$          else
!!$               !call external_joining(iend, ierr_join)
!!$          end if
!!$
!!$          ! final joining
!!$          ! the variable iend is 1 only at the very end when everthing is joined
!!$          ! and the result is available in prop_s%prev
!!$          !
!!$          ! this has to happen only once to finalize everything
!!$          if (iend .eq. 1) then
!!$!             print *, ' '
!!$!             print *, 'FINAL JOINING'
!!$!             print *, ' '
!!$!             ! for internal reasons the result has to be duplicated also to the
!!$!             ! second entry of prop_s
!!$!             CALL assign_propagator_content(prop_s,prop_s%prev)
!!$!             ! now comes the final joining
!!$!             prop_c_old => prop_s%prev
!!$!             prop_c_new => prop_s
!!$!             CALL join_ripples_interface(ierr_join,'final')
!!$!             prop_s => prop_s%prev
!!$!             ! and the final result is in prop_s now
!!$!
!!$!             ! this is just for final output
!!$!             prop_a => prop_s
!!$!
!!$!             CALL diag_propagator_result(iend)
!!$!             CALL diag_propagator_distrf
!!$!
!!$!             IF (prop_write .EQ. 1) THEN
!!$!                ! final joining
!!$!                CALL write_propagator_content(prop_a,2)
!!$!             ELSEIF (prop_write .EQ. 2) THEN
!!$!                ! final joining
!!$!                CALL write_propagator_content(prop_a,4)
!!$!             END IF
!!$!             IF (prop_write .EQ. 1 .OR. prop_write .EQ. 2) THEN
!!$!                ! taginfo
!!$!                CALL unit_propagator
!!$!                OPEN(unit=prop_unit,file=prop_ctaginfo,status='replace', &
!!$!                     form=prop_format,action='write')
!!$!                WRITE(prop_unit,*) prop_write
!!$!                WRITE(prop_unit,*) prop_first_tag   ! UNSOLVED PROBLEM
!!$!                WRITE(prop_unit,*) prop_last_tag    ! UNSOLVED PROBLEM
!!$!                CLOSE(unit=prop_unit)
!!$!             END IF
!!$
!!$          end if
!!$
!!$          ! deallocate
!!$          ! here everything is related to prop_c is deconstructed to be able
!!$          ! to start again for a new group of fieldperiods
!!$          propagator_tag_counter = 0
!!$          prop_count_call = 0
!!$          call destruct_all_propagators
!!$
!!$       end do allperiods_p
!!$       ! this is the end of the while-loop, which terminates at iend=1
    else
       write (*,*) 'This parallel mode is not implemented! Stopping program!'
       write (*,*) 'Please have a look at propagator.f90'
       stop
    end if
  end SUBROUTINE propagator_solver_all
  ! ---------------------------------------------------------------------------

  subroutine external_joining()!, prop1, prop2)
    integer :: iend_sol = 0
    integer :: ierr_join
    !type(propagator), pointer :: prop1
    !type(propagator), pointer :: prop2

    ! Note that most of the commented lines were moved to the workunit (wuGenericNeo2Workunit.f90)

    print *, ' '
    print *, 'EXTERNAL JOINING'
    print *, ' '

    ! call construct_propagator(prop_s)

    ! the result of the new group of fieldperiods is stored in the
    ! second entry of prop_s

    ! CALL assign_propagator_content(prop_s,prop_c%prev)
    ! prop_c_old and prop_c_new are pointers two propagators, which
    ! have to be joined. here it points to the two results stored in
    ! prop_s

    ! write (*,*) allocated(prop1%p%cmat), allocated(prop2%p%cmat)

    ! prop_c_old => prop1 !prop_s%prev
    ! prop_c_new => prop2 !prop_s

    ! write (*,*) allocated(prop_c_old%p%cmat), allocated(prop_c_new%p%cmat)

    CALL join_ripples_interface(ierr_join)

    ! output after joining
    prop_a => prop_c_old     !For all outputs to files
    CALL diag_propagator_result(iend_sol)                   ! UNSOLVED PROBLEM

    ! now the result of joining is stored in prop_s%prev
    ! it is ready for further joining with next groups of fieldperiods
    ! print *, 'ERROR FROM JOINING PERIODS ',ierr_join
    end subroutine external_joining

    subroutine final_joining()
      integer :: iend
      integer :: ierr_join

      iend = 1 ! iend is one for final joining ?!

      print *, ' '
      print *, 'FINAL JOINING'
      print *, ' '

      ! for internal reasons the result has to be duplicated also to the
      ! second entry of prop_s
      ! CALL assign_propagator_content(prop_s,prop_s%prev)
      ! now comes the final joining
      ! prop_c_old => prop_s%prev
      ! prop_c_new => prop_s
      CALL join_ripples_interface(ierr_join,'final')
      ! prop_s => prop_s%prev
      ! and the final result is in prop_s now

      ! this is just for final output
      prop_a => prop_c_old!prop_s

      CALL diag_propagator_result(iend)
      CALL diag_propagator_distrf

      IF (prop_write .EQ. 1) THEN
        ! final joining
        CALL write_propagator_content(prop_a,2)
      ELSEIF (prop_write .EQ. 2) THEN
         ! final joining
         ! WINNY PAR
#if defined(MPI_SUPPORT)
         if (.not. mpro%isParallel()) then
            ! This should only be done in a sequential run
            CALL write_propagator_content(prop_a,4)
         end if
#endif
        ! WINNY PAR END
      END IF
      
!!$      IF (prop_write .EQ. 1 .OR. prop_write .EQ. 2) THEN
!!$        ! taginfo
!!$        CALL unit_propagator
!!$        OPEN(unit=prop_unit,file=prop_ctaginfo,status='replace', &
!!$          form=prop_format,action='write')
!!$        WRITE(prop_unit,*) prop_write
!!$        WRITE(prop_unit,*) prop_first_tag   ! UNSOLVED PROBLEM
!!$        WRITE(prop_unit,*) prop_last_tag    ! UNSOLVED PROBLEM
!!$        CLOSE(unit=prop_unit)
!!$      END IF
      
    end subroutine final_joining

  ! --- MPI SUPPORT END ---


  ! ---------------------------------------------------------------------------
  SUBROUTINE propagator_solver_loc(iend,iendperiod,bin_split_mode,            &
       eta_ori,ierr_solv,ierr_join                                            &
       )
    !
    USE device_mod
    USE flint_mod , ONLY : phi_split_mode,phi_place_mode,  &
         phi_split_min,hphi_mult,max_solver_try
    USE collisionality_mod, ONLY : isw_axisymm
    USE mag_interface_mod, ONLY : magnetic_device,mag_magfield
             

    ! parameter list
    INTEGER,                      INTENT(in)  :: iend
    INTEGER,                      INTENT(in)  :: iendperiod
    INTEGER,                      INTENT(in)  :: bin_split_mode
    REAL(kind=dp), DIMENSION(0:), INTENT(in)  :: eta_ori
    ! TYPE(binarysplit),            INTENT(in)  :: eta_bs
    INTEGER,                      INTENT(out) :: ierr_solv
    INTEGER,                      INTENT(out) :: ierr_join
    ! 
    ! local quantity

    TYPE(binarysplit)                           :: eta_bs

    INTEGER                                     :: k,sy
    INTEGER                                     :: prop_npart
    INTEGER                                     :: i_joined
    INTEGER                                     :: count_solv
    INTEGER                                     :: phi_split_mode_ori   !<-in Winny
    REAL(kind=dp)                               :: mult_solv

    !
    ! initialize
    ierr_solv = 0
    ierr_join = 0
    sw_last_prop = iend

    fieldripple => fieldpropagator%ch_act
    eta_bs = fieldripple%eta_bs

    IF (bin_split_mode .EQ. 0) THEN
       prop_npart = UBOUND(eta_ori,1)
    ELSE
       prop_npart = UBOUND(eta_bs%x_split,1)
    END IF

    IF (prop_write .NE. 0) THEN
       prop_binary = 0
    END IF
    !
    IF (prop_timing .EQ. 1) CALL cpu_time(time_tot_o)

    ! Counter
    prop_count_call = prop_count_call + 1

    ! First call
    sw_first_prop = 0
    IF (prop_count_call .EQ. 1) THEN
       sw_first_prop = 1
       IF (prop_timing .EQ. 1) THEN
          stime_co  = 0.0_dp
          stime_jp  = 0.0_dp
          stime_ja  = 0.0_dp
          stime_jf  = 0.0_dp
          stime_so  = 0.0_dp
       END IF
       IF (prop_diagnostic .GE. 1) THEN
          PRINT *, '               construct propagator'
       END IF
       ! now construct the new propagator
       IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
       CALL construct_propagator
       prop_c%nr_joined = -1
       IF (prop_timing .EQ. 1) THEN
          CALL cpu_time(time_co)
          stime_co = stime_co + time_co - time_o
       END IF
       prop_c%nr_joined = -1
    END IF

    IF ( (magnetic_device .EQ. 0 .and. isw_axisymm .eq. 1) .or. mag_magfield .eq. 0 ) THEN ! tokamak case

       ! ---------------------------------------------------------------------------
       ! call to ripple_solver for a propagator
       prop_c%bin_split_mode = bin_split_mode
       prop_c%p%npart = prop_npart
       prop_c%fieldpropagator_tag_s = fieldpropagator%tag
       prop_c%fieldpropagator_tag_e = fieldpropagator%tag
       prop_c%fieldperiod_tag_s     = fieldpropagator%parent%tag
       prop_c%fieldperiod_tag_e     = fieldpropagator%parent%tag
       prop_c%phi_l = fieldpropagator%phi_l
       prop_c%phi_r = fieldpropagator%phi_r

       ! put in eta_information
       IF (bin_split_mode .EQ. 1) THEN
          prop_c%eta_bs_l = eta_bs
          prop_c%eta_bs_r = eta_bs
       ENDIF
       IF (ALLOCATED(prop_c%p%eta_l)) DEALLOCATE(prop_c%p%eta_l)
       ALLOCATE(prop_c%p%eta_l( &
            LBOUND(fieldpropagator%ch_act%eta,1):UBOUND(fieldpropagator%ch_act%eta,1) &
            ))
       prop_c%p%eta_l  = fieldpropagator%ch_act%eta
       IF (ALLOCATED(prop_c%p%eta_r)) DEALLOCATE(prop_c%p%eta_r)
       ALLOCATE(prop_c%p%eta_r( &
            LBOUND(fieldpropagator%ch_act%eta,1):UBOUND(fieldpropagator%ch_act%eta,1) &
            ))
       prop_c%p%eta_r  = fieldpropagator%ch_act%eta

       IF (prop_diagnostic .GE. 2) THEN
          PRINT *, '               in ripple_solver ',prop_count_call
          PRINT *, '         ibegperiod, iendperiod ',prop_ibegperiod,iendperiod
       END IF
       IF (prop_timing .EQ. 1) CALL cpu_time(time_o)

       ! try the ripple_solver
       count_solv = 0
       mult_solv  = hphi_mult
       reduce_hphi_axisym: DO
          count_solv = count_solv + 1
          ierr_solv = 0
          CALL ripple_solver_interface(ierr_solv)
          IF (ierr_solv .EQ. 0) EXIT reduce_hphi_axisym
          IF (ierr_solv .NE. 0 .AND. ierr_solv .NE. 3) THEN
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I give up'
             STOP
          END IF

          IF (ierr_solv .EQ. 3 .AND. count_solv .LT. max_solver_try) THEN
             mult_solv = mult_solv * 0.5_dp
             phi_split_mode_ori = phi_split_mode                  !<-in Winny
             phi_split_mode = 3                                   !<-in Winny
             CALL modify_propagator(phi_split_mode,phi_place_mode,phi_split_min, &
                  UBOUND(prop_c%p%eta_l,1),prop_c%p%eta_l,mult_solv,count_solv)
             phi_split_mode = phi_split_mode_ori                  !<-in Winny
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I try it again ',count_solv+1
!!$          IF (count_solv .GT. 1) THEN
!!$             PRINT *, 'PAUSE - MODE'
!!$             PAUSE
!!$          END IF
          ELSE IF (ierr_solv .EQ. 3 .AND. count_solv .GE. max_solver_try) THEN
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I give up'
             STOP
          END IF
       END DO reduce_hphi_axisym
       ! write the end value for y of the field propagator into prop_c
       ! this is for computing physical output
       !sy = SIZE(fieldpropagator%mdata%yend,1)
       sy = SIZE(fieldpropagator%parent%mdata%yend,1) ! WINNY YEND
       IF (ALLOCATED(prop_c%y)) DEALLOCATE(prop_c%y)
       ALLOCATE(prop_c%y(sy))
       !prop_c%y = fieldpropagator%mdata%yend
       prop_c%y = fieldpropagator%parent%mdata%yend ! WINNY YEND
       ! write eta at boundaries - replaced by modified stuff
       !prop_c%p%eta_boundary_l = 1.0_dp / fieldpropagator%b_l
       !prop_c%p%eta_boundary_r = 1.0_dp / fieldpropagator%b_r
       prop_c%p%eta_boundary_l = eta_modboundary_l
       prop_c%p%eta_boundary_r = eta_modboundary_r
       ! link actual to current (mainly for results and diagnostic)
       prop_a => prop_c
       ! writing of propagators
       !IF (prop_write .EQ. 2) THEN
       !   CALL write_propagator_content(prop_a,3)
       !   IF (prop_first_tag .EQ. 0) prop_first_tag = fieldpropagator%tag
       !   prop_last_tag = fieldpropagator%tag
       !END IF
       ! ---------------------------------------------------------------------------
       CALL diag_propagator_result(iend)
       CALL diag_propagator_distrf
    ELSE ! this is the general case
   
       IF (prop_reconstruct .EQ. 0) THEN
          ! Begin of period (no joining of all propagators
          IF (prop_ibegperiod .EQ. 1 .AND. prop_write .NE. 2) THEN
             IF (prop_c%nr_joined .EQ. -1 .AND. .NOT. ASSOCIATED(prop_c%next)) THEN
                IF (prop_diagnostic .GE. 1) THEN
                   PRINT *, '               construct propagator'
                END IF
                IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
                CALL construct_propagator
                IF (prop_timing .EQ. 1) THEN
                   CALL cpu_time(time_co)
                   stime_co = stime_co + time_co - time_o
                END IF
                prop_c%nr_joined = -1
                prop_c => prop_c%prev
             END IF
             prop_a => prop_c
          END IF
       END IF

       IF (prop_reconstruct .EQ. 2) THEN
          CALL read_prop_recon_content(fieldpropagator%tag)
       END IF
       ! ---------------------------------------------------------------------------
       ! call to ripple_solver for a propagator
       prop_c%bin_split_mode = bin_split_mode
       prop_c%p%npart = prop_npart
       prop_c%fieldpropagator_tag_s = fieldpropagator%tag
       prop_c%fieldpropagator_tag_e = fieldpropagator%tag
       prop_c%fieldperiod_tag_s     = fieldpropagator%parent%tag
       prop_c%fieldperiod_tag_e     = fieldpropagator%parent%tag
       prop_c%phi_l = fieldpropagator%phi_l
       prop_c%phi_r = fieldpropagator%phi_r

       ! put in eta_information
       IF (bin_split_mode .EQ. 1) THEN
          prop_c%eta_bs_l = eta_bs
          prop_c%eta_bs_r = eta_bs
       ENDIF
       IF (ALLOCATED(prop_c%p%eta_l)) DEALLOCATE(prop_c%p%eta_l)
       ALLOCATE(prop_c%p%eta_l( &
            LBOUND(fieldpropagator%ch_act%eta,1):UBOUND(fieldpropagator%ch_act%eta,1) &
            ))
       prop_c%p%eta_l  = fieldpropagator%ch_act%eta
       IF (ALLOCATED(prop_c%p%eta_r)) DEALLOCATE(prop_c%p%eta_r)
       ALLOCATE(prop_c%p%eta_r( &
            LBOUND(fieldpropagator%ch_act%eta,1):UBOUND(fieldpropagator%ch_act%eta,1) &
            ))
       prop_c%p%eta_r  = fieldpropagator%ch_act%eta

       IF (prop_diagnostic .GE. 2) THEN
          PRINT *, '               in ripple_solver ',prop_count_call
          PRINT *, '         ibegperiod, iendperiod ',prop_ibegperiod,iendperiod
       END IF
       IF (prop_timing .EQ. 1) CALL cpu_time(time_o)

       ! try the ripple_solver
       count_solv = 0
       mult_solv  = hphi_mult
       reduce_hphi: DO
          count_solv = count_solv + 1
          ierr_solv = 0
          CALL ripple_solver_interface(ierr_solv)
          IF (ierr_solv .EQ. 0) EXIT reduce_hphi
          IF (ierr_solv .NE. 0 .AND. ierr_solv .NE. 3) THEN
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I give up'
             STOP
          END IF

          IF (ierr_solv .EQ. 3 .AND. count_solv .LT. max_solver_try) THEN
             mult_solv = mult_solv * 0.5_dp
             phi_split_mode_ori = phi_split_mode                  !<-in Winny
             phi_split_mode = 3                                   !<-in Winny
             CALL modify_propagator(phi_split_mode,phi_place_mode,phi_split_min, &
                  UBOUND(prop_c%p%eta_l,1),prop_c%p%eta_l,mult_solv,count_solv)
             phi_split_mode = phi_split_mode_ori                  !<-in Winny
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I try it again ',count_solv+1
!!$          IF (count_solv .GT. 1) THEN
!!$             PRINT *, 'PAUSE - MODE'
!!$             PAUSE
!!$          END IF
          ELSE IF (ierr_solv .EQ. 3 .AND. count_solv .GE. max_solver_try) THEN
             PRINT *, 'Error in ripple_solver: ',ierr_solv
             PRINT *, ' I give up'
             STOP
          END IF
       END DO reduce_hphi

       IF (prop_reconstruct .EQ. 2) RETURN

       ! write the end value for y of the field propagator into prop_c
       ! this is for computing physical output
       !sy = SIZE(fieldpropagator%mdata%yend,1)
       sy = SIZE(fieldpropagator%parent%mdata%yend,1) ! WINNY YEND
       IF (ALLOCATED(prop_c%y)) DEALLOCATE(prop_c%y)
       ALLOCATE(prop_c%y(sy))
       !prop_c%y = fieldpropagator%mdata%yend
       prop_c%y = fieldpropagator%parent%mdata%yend ! WINNY YEND
       ! write eta at boundaries - replaced by modified stuff
       !prop_c%p%eta_boundary_l = 1.0_dp / fieldpropagator%b_l
       !prop_c%p%eta_boundary_r = 1.0_dp / fieldpropagator%b_r
       prop_c%p%eta_boundary_l = eta_modboundary_l
       prop_c%p%eta_boundary_r = eta_modboundary_r
       ! link actual to current (mainly for results and diagnostic)
       prop_a => prop_c
       ! writing of propagators
       !print *, 'I am before IF (prop_write .EQ. 2) THEN'
       IF (prop_write .EQ. 2) THEN
          !print *, 'I am before CALL write_propagator_content(prop_a,3)'
          CALL write_propagator_content(prop_a,3)
          ! WINNY PAR
          ! This should only be done in a parallel run
#if defined(MPI_SUPPORT)
          if (mpro%isParallel()) then
             !print *, 'I am before write_binarysplit_content(prop_a)' 
             CALL write_binarysplit_content(prop_a)
          end if
#endif
          ! WINNY PAR END
          IF (prop_first_tag .EQ. 0) prop_first_tag = fieldpropagator%tag
          prop_last_tag = fieldpropagator%tag
       END IF
       ! ---------------------------------------------------------------------------
       IF (prop_diagphys .EQ. 1) THEN
          CALL diag_propagator_content
       END IF
       ! ---------------------------------------------------------------------------
       IF (prop_timing .EQ. 1) THEN
          CALL cpu_time(time_so)
          stime_so = stime_so + time_so - time_o
       END IF

       ! make a new propagator or join
       i_joined = 0
       ! ---------------------------------------------------------------------------
       IF (prop_ibegperiod .EQ. 1 .AND. iendperiod .EQ. 1 .AND. prop_write .NE. 2) THEN 
          i_joined = 1
          prop_a => prop_c
          prop_ibegperiod = 1
          prop_c%nr_joined = 0
          prop_c => prop_c%next
          IF (.NOT. ASSOCIATED(prop_c%next)) THEN
             CALL construct_propagator
             prop_c%nr_joined = -3
             prop_c => prop_c%prev
          END IF
       ELSEIF (prop_count_call .EQ. 1 .AND. prop_write .EQ. 2) THEN
          CALL construct_propagator
          prop_c%nr_joined = -1
          ! prop_c => prop_c%prev
          prop_a => prop_c       
       ELSE
          IF (prop_ibegperiod .EQ. 0 .OR. iendperiod .EQ. 1 .OR. prop_write .EQ. 2) THEN 
             IF (prop_diagnostic .GE. 2) THEN
                PRINT *, '               join_ripples within period'
             END IF
             IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
             print *, 'JOINED in period prop_c%tag ',prop_c%prev%tag,prop_c%tag
             prop_c_old => prop_c%prev
             prop_c_new => prop_c
             CALL join_ripples_interface(ierr_join,'inter',0)
             i_joined = 1
             IF (prop_timing .EQ. 1) THEN
                CALL cpu_time(time_jp)
                stime_jp = stime_jp + time_jp - time_o
             END IF
             prop_a => prop_c%prev
             ! writing of propagators (joined within period)
             IF (prop_write .EQ. 2) THEN 
                ! WINNY PAR
                ! This should only be done in a sequential run
#if defined(MPI_SUPPORT)
                if (.not. mpro%isParallel()) then
                   CALL write_prop_bound_content(prop_c%prev,prop_c,3)
                   CALL write_propagator_content(prop_c%prev,3,2) ! reduced for joined
                end if
#endif
                ! END WINNY PAR
             END IF
             IF (ALLOCATED(prop_c%prev%p%cmat)) DEALLOCATE(prop_c%prev%p%cmat)
             IF (ALLOCATED(prop_c%p%cmat)) DEALLOCATE(prop_c%p%cmat)

          END IF
          IF (prop_ibegperiod .EQ. 1 .AND. prop_write .NE. 2) THEN
             prop_c => prop_c%next
          END IF
          IF (prop_ibegperiod .EQ. 1) THEN
             prop_ibegperiod = 0
          END IF
          IF (iendperiod .EQ. 1) THEN
             ! writing of periods
             ! Winny: This is the place to write things to the file
             ! Things at this point are in prop_a => prop_c%prev
             ! cmat is computed when you join periods, so it can not be written here
             IF (prop_write .EQ. 1) THEN 
                CALL write_propagator_content(prop_a,1)
                IF (prop_first_tag .EQ. 0) prop_first_tag = fieldpropagator%parent%tag
                prop_last_tag = fieldpropagator%parent%tag
             END IF
             ! Winny
             prop_ibegperiod = 1
             prop_c%nr_joined = -1
             IF (prop_write .NE. 2) THEN
                prop_c%prev%nr_joined = 0
             END IF
          END IF
       END IF
       ! ---------------------------------------------------------------------------


       ! ---------------------------------------------------------------------------
       ! Check for advanced joining
       IF (iendperiod .EQ. 1 .AND. prop_write .NE. 2) THEN
          prop_c => prop_c%prev
          ! Binary joining
          IF (prop_binary .EQ. 1) THEN
             k = 1
             DO
                IF ( .NOT. ASSOCIATED(prop_c%prev) ) EXIT
                IF ( prop_c%nr_joined .EQ. prop_c%prev%nr_joined ) THEN
                   k = k + 1
                   IF (prop_diagnostic .GE. 1) THEN
                      PRINT *, '               join_ripples advanced binary',k
                   END IF
                   IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
                   print *, 'JOINED advanced binary prop_c%tag ',prop_c%prev%tag,prop_c%tag
                   prop_c_old => prop_c%prev
                   prop_c_new => prop_c
                   CALL join_ripples_interface(ierr_join)
                   IF (ALLOCATED(prop_c%prev%p%cmat)) DEALLOCATE(prop_c%prev%p%cmat)
                   IF (ALLOCATED(prop_c%p%cmat)) DEALLOCATE(prop_c%p%cmat)
                   i_joined = 1
                   IF (prop_timing .EQ. 1) THEN
                      CALL cpu_time(time_ja)
                      stime_ja = stime_ja + time_ja - time_o
                   END IF
                   prop_c%nr_joined = -1
                   prop_c => prop_c%prev
                   prop_c%nr_joined = k
                   prop_a => prop_c
                ELSE
                   EXIT
                END IF
             END DO
          ELSE
             IF ( ASSOCIATED(prop_c%prev) ) THEN
                k = 2
                IF (prop_diagnostic .GE. 1) THEN
                   PRINT *, '               join_ripples advanced period',k
                END IF
                IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
                print *, 'JOINED advanced period prop_c%tag ',prop_c%prev%tag,prop_c%tag
                prop_c_old => prop_c%prev
                prop_c_new => prop_c
                CALL join_ripples_interface(ierr_join,'inter',0)
                ! Winny 
                ! here the periods are joined, so cmat should be available
                ! but cmat is not stored, so this has to be handled
                ! PRINT *, 'Joining of periods'
                ! PRINT *,fieldpropagator%parent%prev%tag
                ! PRINT *,fieldpropagator%parent%tag
                IF (prop_write .EQ. 1) CALL write_prop_bound_content(prop_c%prev,prop_c,1)
                IF (ALLOCATED(prop_c%prev%p%cmat)) DEALLOCATE(prop_c%prev%p%cmat)
                IF (ALLOCATED(prop_c%p%cmat)) DEALLOCATE(prop_c%p%cmat)
                IF (prop_write .EQ. 1) CALL write_propagator_content(prop_c%prev,1,2)
                ! Winny
                i_joined = 1
                IF (prop_timing .EQ. 1) THEN
                   CALL cpu_time(time_ja)
                   stime_ja = stime_ja + time_ja - time_o
                END IF
                prop_c%nr_joined = -1
                prop_c => prop_c%prev
                prop_c%nr_joined = 1
                prop_a => prop_c
             END IF
          END IF
          prop_c => prop_c%next
       END IF

       ! Final joining
       IF (iend .EQ. 1) THEN
          k = 1
          DO 
             prop_c => prop_c%prev
             IF ( ASSOCIATED(prop_c%prev) ) THEN
                k = k + 1
                IF (prop_diagnostic .GE. 1) THEN
                   PRINT *, '               final joining ',k
                END IF
                IF (prop_timing .EQ. 1) CALL cpu_time(time_o)
                print *, 'JOINED final prop_c%tag ',prop_c%prev%tag,prop_c%tag
                prop_c_old => prop_c%prev
                prop_c_new => prop_c
                CALL join_ripples_interface(ierr_join)
                i_joined = 1 
                IF (prop_timing .EQ. 1) THEN
                   CALL cpu_time(time_jf)
                   stime_jf = stime_jf + time_jf - time_o
                END IF
             ELSE 
                ! join ends
                IF (prop_join_ends .EQ. 1) THEN
                   i_joined = 1
                   !CALL construct_propagator()
                   !print *, 'CREATED prop_c%tag ',prop_c%tag
                   prop_c => prop_c%next
                   CALL assign_propagator_content(prop_c,prop_c%prev)
                   print *, 'JOINED join ends prop_c%tag ',prop_c%prev%tag,prop_c%tag
                   prop_c_old => prop_c%prev
                   prop_c_new => prop_c
                   CALL join_ripples_interface(ierr_join,'final')
                   prop_c => prop_c%prev
                END IF
                !
                prop_a => prop_c_old
                IF (prop_write .EQ. 1) THEN
                   ! final joining
                   CALL write_propagator_content(prop_a,2)
                ELSEIF (prop_write .EQ. 2) THEN
                   ! final joining
                   ! WINNY PAR
#if defined(MPI_SUPPORT)
                   if (.not. mpro%isParallel()) then
                      ! This should only be done in a sequential run
                      CALL write_propagator_content(prop_a,4)
                      ! WINNY PAR END
                   end if
#endif
                END IF
                !IF (prop_write .EQ. 1 .OR. prop_write .EQ. 2) THEN
                   ! --- Lines commented out by Gernot ---
                   ! --- otherwise taginfo.prop is replaced by a wrong version ---
		   ! taginfo
                   !CALL unit_propagator
                   !OPEN(unit=prop_unit,file=prop_ctaginfo,status='replace', &
                   !     form=prop_format,action='write')
                   ! WINNY PAR
                   ! The last tag is wrong in a parallel run
                   !WRITE(prop_unit,*) prop_write
                   !WRITE(prop_unit,*) prop_first_tag
                   !WRITE(prop_unit,*) prop_last_tag
                   ! WINNY PAR END
                   !CLOSE(unit=prop_unit)
                !END IF
                EXIT
             END IF
          END DO
       END IF
       !
       IF (prop_timing .EQ. 1) THEN
          CALL cpu_time(time_tot)
          stime_tot = stime_tot + time_tot - time_tot_o
       END IF
       ! diagnostic
       IF (i_joined .EQ. 1 .AND. prop_diagphys .EQ. 1) THEN
          CALL diag_propagator_content 
       END IF
       ! physical output
       IF (i_joined .EQ. 1 .AND. iendperiod .EQ. 1) THEN
          CALL diag_propagator_result(iend)
       END IF

       IF (i_joined .EQ. 1 .AND. iend .EQ. 1) THEN
          CALL diag_propagator_distrf 
       END IF
    end IF

    IF (iend .EQ. 1 .AND. prop_timing .EQ. 1) THEN
       PRINT *, ' '
       PRINT *, 'Time for construction      :', stime_co 
       PRINT *, 'Time for solver            :', stime_so
       PRINT *, 'Time for joining in period :', stime_jp 
       PRINT *, 'Time for advanced joining  :', stime_ja 
       PRINT *, 'Time for final joining     :', stime_jf
       PRINT *, ' '
       PRINT *, 'Total Time for joining     :', stime_jp + stime_ja + stime_jf
       PRINT *, 'Total Time in module       :', stime_tot 
       PRINT *, ' '
    END IF

    CALL deconstruct_binarysplit(eta_bs)

    !
  END SUBROUTINE propagator_solver_loc
  
  ! ---------------------------------------------------------------------------
  SUBROUTINE ripple_solver_int(ierr)
    !
    ! Interface routine for subroutine ripple_solver
    ! Connects to the outside
    !
    ! Has to be changed if physical content of propagator changes!
    ! (see type declaration of propagator)
    !
    ! Call to external program ripple_solver
    INTEGER :: ierr
    
    INTERFACE ripple_solver
       SUBROUTINE ripple_solver(                                 &
            npass_l,npass_r,nvelocity,                           &         !<-in
            amat_plus_plus,amat_minus_minus,                     &
            amat_plus_minus,amat_minus_plus,                     &
            source_p,source_m,                                   &         !<-in
            flux_p,flux_m,                                       &
            qflux,                                               &         !<-in
            ierr                                                 &
            )
         INTEGER, PARAMETER                                        :: dp = KIND(1.0d0)

         INTEGER,                                    INTENT(out)   :: npass_l
         INTEGER,                                    INTENT(out)   :: npass_r
         INTEGER,   INTENT(out)   :: nvelocity                              !<-in
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(inout) :: amat_plus_plus
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(inout) :: amat_minus_minus
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(inout) :: amat_plus_minus
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(inout) :: amat_minus_plus
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(inout) ::         &
                                       source_p,source_m,flux_p,flux_m     !<-in
         REAL(kind=dp), DIMENSION(:,:), ALLOCATABLE, INTENT(out) :: qflux  !<-in
         INTEGER,                                    INTENT(out)   :: ierr
       END SUBROUTINE ripple_solver
    END INTERFACE

    CALL ripple_solver(                                                  &
         prop_c%p%npass_l,prop_c%p%npass_r,prop_c%p%nvelocity,           & !<-in
         prop_c%p%amat_p_p, prop_c%p%amat_m_m,                           &
         prop_c%p%amat_p_m, prop_c%p%amat_m_p,                           &
         prop_c%p%source_p, prop_c%p%source_m,                           & !<-in
         prop_c%p%flux_p, prop_c%p%flux_m,                               & 
         prop_c%p%qflux,                                                 & !<-in
         ierr                                                            &
         )

    prop_c%p%npass_l = SIZE(prop_c%p%amat_p_m,1)/(prop_c%p%nvelocity+1)     !<-in
    prop_c%p%npass_r = SIZE(prop_c%p%amat_m_p,1)/(prop_c%p%nvelocity+1)     !<-in
    !
  END SUBROUTINE ripple_solver_int

  SUBROUTINE plot_distrf_int
  
    INTERFACE ripple_solver
       SUBROUTINE plot_distrf(source_p,source_m,eta_l,eta_r,eta_boundary_l,eta_boundary_r)
         INTEGER, PARAMETER :: dp = KIND(1.0d0)
         
         REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE, INTENT(inout) :: source_p
         REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE, INTENT(inout) :: source_m
         REAL(kind=dp), DIMENSION(:),     ALLOCATABLE, INTENT(inout) :: eta_l
         REAL(kind=dp), DIMENSION(:),     ALLOCATABLE, INTENT(inout) :: eta_r
         REAL(kind=dp)                               , INTENT(inout) :: eta_boundary_l
         REAL(kind=dp)                               , INTENT(inout) :: eta_boundary_r
       END SUBROUTINE plot_distrf
    END INTERFACE

    CALL plot_distrf(prop_a%p%source_p,prop_a%p%source_m,prop_a%p%eta_l,prop_a%p%eta_r, &
         prop_a%p%eta_boundary_l,prop_a%p%eta_boundary_r)

  END SUBROUTINE plot_distrf_int

  SUBROUTINE join_ripples_int(ierr,cstat_in,deall_in)
    !  
    ! Interface for subroutine join_ripples
    ! Joines current propagator prop_c with previous propagator prop_c%prev
    ! and puts result into the previous one.
    !
    ! Has to be changed if physical content of propagator changes!
    ! (see type declaration of propagator)
    !
    ! Call to external program join_ripples
    USE binarysplit_mod
    
    INTEGER, INTENT(out) :: ierr
    CHARACTER(len=5), OPTIONAL, INTENT(in) :: cstat_in
    INTEGER, OPTIONAL, INTENT(in) :: deall_in

    CHARACTER(len=5)                     :: cstat
    
    TYPE(propagator), POINTER            :: o
    TYPE(propagator), POINTER            :: n
    
    TYPE(binarysplit)                    :: loc_bs_1a,loc_bs_2a
    TYPE(binarysplit)                    :: loc_bs_1b,loc_bs_2b
    
    INTEGER :: i
    INCLUDE 'longint.f90'
    INTEGER(kind=longint), DIMENSION(:,:), ALLOCATABLE :: bin1,bin2
    INTEGER :: deall

    REAL(kind=dp),   DIMENSION(:,:), ALLOCATABLE :: cmat_help
    ierr = 0
    
    !o => prop_c%prev
    !n => prop_c

    o => prop_c_old
    n => prop_c_new

    !prop_c_old => o
    !prop_c_new => n
     



    IF (PRESENT(cstat_in)) THEN
       cstat = cstat_in
    ELSE
       cstat = 'inter'
    END IF
    IF (PRESENT(deall_in)) THEN
       deall = deall_in
    ELSE
       deall = 1
    END IF


    ! allocate cmat (c_forward and c_backward)
    ! c_forward
    !write (*,*) "Associated o and n: ", associated(o), associated(n)
    !write (*,*) o%p%npart
    IF (ALLOCATED(o%p%cmat)) DEALLOCATE(o%p%cmat)
    ALLOCATE( o%p%cmat(o%p%npass_r,o%p%npass_r) )
    o%p%cmat = 0.0_dp
    DO i = 1,o%p%npass_r
       o%p%cmat(i,i) = 1.0_dp
    END DO
    ! c_backward
    IF (ALLOCATED(n%p%cmat)) DEALLOCATE(n%p%cmat)
    ALLOCATE( n%p%cmat(n%p%npass_l,n%p%npass_l) )
    n%p%cmat = 0.0_dp
    DO i = 1,n%p%npass_l
       n%p%cmat(i,i) = 1.0_dp
    END DO
    ! 

    IF (prop_diagnostic .GE. 1) THEN
       PRINT *, ' '
       PRINT *, 'I am in join_ripples'
       PRINT *, ' '
       PRINT *, ' bin_split_mode old new   ', o%bin_split_mode,n%bin_split_mode
       PRINT *, ' ubound(x_split)old new l ', UBOUND(o%eta_bs_l%x_split,1), &
            UBOUND(n%eta_bs_l%x_split,1)
       PRINT *, ' ubound(x_split)old new r ', UBOUND(o%eta_bs_r%x_split,1), &
            UBOUND(n%eta_bs_r%x_split,1)
       PRINT *, ' npart old new            ', o%p%npart,n%p%npart
       PRINT *, ' npass_l old new          ', o%p%npass_l,n%p%npass_l
       PRINT *, ' npass_r old new          ', o%p%npass_r,n%p%npass_r
       PRINT *, ' '
    END IF
        
    IF (o%bin_split_mode .NE. n%bin_split_mode) THEN
       PRINT *, 'ERROR: A difference of bin_split_mode of 1 and 2'
       PRINT *, '       cannot be handled!'
       STOP
    END IF

    ! now we have to modifiy c_forward and c_backward
    IF (o%bin_split_mode .EQ. 1) THEN

       ! we first fix it forward
       prop_modifyold = 1       
       ! first: remove those splits in old which are not in new
       IF (prop_diagnostic .GE. 3) THEN
          PRINT *, 'JOIN binarysplit action - forward'
       END IF
       ! look for splits which are in o%eta_bs_r and not in n%eta_bs_l
       CALL compare_binarysplit(o%eta_bs_r,n%eta_bs_l,bin1,'diff')
       ! do the joining of levels
       ! use bin1 to remove them from o%eta_bs_r
       CALL join_binarysplit(loc_bs_1a,o%eta_bs_r,bin1)
       ! now loc_bs_1a is the modified o%eta_bs_r

       ! second: create those splits in old which are not in new
       IF (prop_diagnostic .GE. 3) THEN
          PRINT *, 'SPLIT binarysplit action - forward'
       END IF
       ! 
       CALL compare_binarysplit(n%eta_bs_l,loc_bs_1a,bin2,'diff')
       ! do the splitting of levels
       CALL dosplit_binarysplit(loc_bs_2a,loc_bs_1a,bin2)
       ! now loc_bs_2a is the final modified o%eta_bs_r

       ! remove unnecessary things
       IF (ALLOCATED(bin1)) DEALLOCATE(bin1)
       IF (ALLOCATED(bin2)) DEALLOCATE(bin2)

       ! now we fix it backward
       prop_modifyold = 0       
       ! first: remove those splits in new which are not in old
       IF (prop_diagnostic .GE. 3) THEN
          PRINT *, 'JOIN binarysplit action - backward'
       END IF
       CALL compare_binarysplit(n%eta_bs_l,o%eta_bs_r,bin1,'diff')
       ! do the joining of levels
       CALL join_binarysplit(loc_bs_1b,n%eta_bs_l,bin1)
       ! now loc_bs_1b is the modified n%eta_bs_l

       ! second: create those splits in new which are not in old
       IF (prop_diagnostic .GE. 3) THEN
          PRINT *, 'SPLIT binarysplit action - backward'
       END IF
       CALL compare_binarysplit(o%eta_bs_r,loc_bs_1b,bin2,'diff')
       ! do the splitting of levels
       CALL dosplit_binarysplit(loc_bs_2b,loc_bs_1b,bin2)
       ! now loc_bs_2b is the final modified n%eta_bs_l - not needed

       ! put the eta_information on right side of propagator
       ! o%eta_bs_r = loc_bs_2a 
       ! CALL get_binarysplit(loc_bs_2a,o%p%eta_r,'x')
       ! put the eta_information on left side of propagator
       ! n%eta_bs_l = loc_bs_2b 
       ! CALL get_binarysplit(loc_bs_2b,n%p%eta_l,'x')

       ! remove unnecessary things
       IF (ALLOCATED(bin1)) DEALLOCATE(bin1)
       IF (ALLOCATED(bin2)) DEALLOCATE(bin2)
       
       IF (cstat .EQ. 'final') THEN
       IF (prop_diagnostic .GE. 2) THEN     
          OPEN(unit=1000,file='c_forward.dat')
          DO i = 1,SIZE(o%p%cmat,1)
             WRITE(1000,'(1000e14.5)') o%p%cmat(i,:)
          END DO
          CLOSE(unit=1000)
          OPEN(unit=1000,file='c_backward.dat')
          DO i = 1,SIZE(n%p%cmat,1)
             WRITE(1000,'(1000e14.5)') n%p%cmat(i,:)
          END DO
          CLOSE(unit=1000)

          ALLOCATE(cmat_help( n%p%npass_l,n%p%npass_l ))
          OPEN(unit=1000,file='forward_backward.dat')
          cmat_help = MATMUL(o%p%cmat,n%p%cmat)
          DO i = 1,n%p%npass_l
             WRITE(1000,'(1000e14.5)') cmat_help(i,:)
          END DO
          CLOSE(unit=1000)
          DEALLOCATE(cmat_help)

          ALLOCATE(cmat_help( o%p%npass_r,o%p%npass_r ))
          OPEN(unit=1000,file='backward_forward.dat')
          cmat_help = MATMUL(n%p%cmat,o%p%cmat)
          DO i = 1,o%p%npass_r
             WRITE(1000,'(1000e14.5)') cmat_help(i,:)
          END DO
          CLOSE(unit=1000)
          DEALLOCATE(cmat_help)

          PRINT *,  'size of c_forward:    ', SIZE(o%p%cmat,1),SIZE(o%p%cmat,2)
          PRINT *,  ' should be            ', n%p%npass_l, o%p%npass_r
          PRINT *,  'size of c_backward:   ', SIZE(n%p%cmat,1),SIZE(n%p%cmat,2)
          PRINT *,  ' should be            ', o%p%npass_r, n%p%npass_l

          PRINT *,  'old propagator tag:   ', o%fieldpropagator_tag_s,o%fieldpropagator_tag_e
          PRINT *,  'size of o%p%amat_m_p: ', SIZE(o%p%amat_m_p,1),SIZE(o%p%amat_m_p,2)
!->out          PRINT *,  ' should be            ', o%p%npass_r, o%p%npass_r
          PRINT *,  ' should be            ', o%p%npass_r*(o%p%nvelocity+1), o%p%npass_r*(o%p%nvelocity+1) !<-in

          PRINT *,  'new propagator tag:   ', n%fieldpropagator_tag_s,n%fieldpropagator_tag_e
          PRINT *,  'size of n%p%amat_p_m: ', SIZE(n%p%amat_p_m,1),SIZE(n%p%amat_p_m,2)
!->out          PRINT *,  ' should be            ', n%p%npass_l, n%p%npass_l
          PRINT *,  ' should be            ', n%p%npass_l*(n%p%nvelocity+1), n%p%npass_l*(n%p%nvelocity+1)  !<-in
          

          PRINT *, 'Difference in forward'
          DO i = 0,UBOUND(loc_bs_2a%x_split,1)
             IF (loc_bs_2a%x_split(i) .NE. n%eta_bs_l%x_split(i)) THEN
                PRINT *, 'loc_bs not equal: ',i,loc_bs_2a%x_split(i),n%eta_bs_l%x_split(i)
             END IF
          END DO

          PRINT *, 'Difference in backward'
          DO i = 0,UBOUND(loc_bs_2b%x_split,1)
             IF (loc_bs_2b%x_split(i) .NE. o%eta_bs_r%x_split(i)) THEN
                PRINT *, 'loc_bs not equal: ',i,loc_bs_2b%x_split(i),o%eta_bs_r%x_split(i)
             END IF
          END DO

          CALL compare_binarysplit(loc_bs_2a,n%eta_bs_l,bin1,'diff')
          !CALL printbin_binarysplit(bin1)
          PRINT *, 'Count difference forward:  ', COUNT(bin1 .NE. 0)
          IF (ALLOCATED(bin1)) DEALLOCATE(bin1)
          CALL compare_binarysplit(loc_bs_2b,o%eta_bs_r,bin1,'diff')
          !CALL printbin_binarysplit(bin1)
          PRINT *, 'Count difference backward:   ', COUNT(bin1 .NE. 0)
          IF (ALLOCATED(bin1)) DEALLOCATE(bin1)

          PRINT *, 'c_forward.dat and c_backward.dat written'
          !PAUSE
       END IF       
       END IF
       CALL deconstruct_binarysplit(loc_bs_1a)
       CALL deconstruct_binarysplit(loc_bs_2a)
       CALL deconstruct_binarysplit(loc_bs_1b)
       CALL deconstruct_binarysplit(loc_bs_2b)
    END IF



    
    IF (prop_diagnostic .GE. 2) THEN
       PRINT *, ' '
       PRINT *, ' I am now after binarysplit joining amd splitting'
       PRINT *, ' npart old new          ', o%p%npart,n%p%npart
       PRINT *, ' npass_l old new        ', o%p%npass_l,n%p%npass_l
       PRINT *, ' npass_r old new        ', o%p%npass_r,n%p%npass_r
       PRINT *, ' '    
    END IF

    ! here the two arrays c_forward and c_backward should be finished
    ! and passed on to the join_ripples program
    CALL join_ripples_nn(ierr,cstat)
    IF (ierr .NE. 0) THEN
       PRINT *, 'Error from Joining, ierr=',ierr
       STOP
    END IF

    IF (cstat .EQ. 'inter') THEN
       o%fieldperiod_tag_e = n%fieldperiod_tag_e
       o%fieldpropagator_tag_e = n%fieldpropagator_tag_e
    END IF

    ! WINNY PAR
    ! unclear
    ! final cleaning
    IF (deall .EQ. 1) THEN
       IF (ALLOCATED(o%p%cmat)) DEALLOCATE(o%p%cmat)
       IF (ALLOCATED(n%p%cmat)) DEALLOCATE(n%p%cmat)
    END IF
    ! WINNY PAR END

    NULLIFY(o)
    NULLIFY(n)
    
    !
    RETURN
  END SUBROUTINE join_ripples_int
  ! ---------------------------------------------------------------------------

  subroutine write_propagator_cont(o,prop_type,prop_showall_in)
    ! writes the content of a propagator, which is specified in pointer o

    TYPE(propagator), POINTER  :: o

    INTEGER, INTENT(in) :: prop_type
    INTEGER, INTENT(in),OPTIONAL  :: prop_showall_in

    INTEGER :: prop_bound
    INTEGER :: prop_start
    INTEGER :: prop_end
    INTEGER :: prop_showall

    CHARACTER(len=100) :: prop_cfilename_h5

     
    if (present(prop_showall_in)) then
       prop_showall = prop_showall_in
    else
       prop_showall = 1
    end if
    
    prop_bound = 0
    IF (prop_type .EQ. 1) THEN ! period
       prop_start = o%fieldperiod_tag_s
       prop_end   = o%fieldperiod_tag_e
    ELSEIF (prop_type .EQ. 2 .OR. prop_type .EQ. 4) THEN ! final
       prop_start = 0
       prop_end   = 0
    ELSEIF (prop_type .EQ. 3) THEN ! normal propagator
       prop_start = o%fieldpropagator_tag_s
       prop_end   = o%fieldpropagator_tag_e
    ELSE
       PRINT *, 'Propagator Writing: prop_type not implemented: ',prop_type
       RETURN
    END IF

    CALL filename_propagator(prop_type,prop_bound,prop_start,prop_end)
    
    if (prop_fileformat .eq. 1) then
       write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))

       call h5_create(prop_cfilename_h5, h5id)

       call h5_add(h5id, 'prop_start', prop_start)
       call h5_add(h5id, 'prop_end', prop_end)

       if (prop_showall .eq. 1) then
          call h5_add(h5id, 'nr_joined', o%nr_joined)
          call h5_add(h5id, 'fieldpropagator_tag_s', o%fieldpropagator_tag_s)
          call h5_add(h5id, 'fieldpropagator_tag_e', o%fieldpropagator_tag_e)
          call h5_add(h5id, 'fieldperiod_tag_s', o%fieldperiod_tag_s)
          call h5_add(h5id, 'fieldperiod_tag_e',  o%fieldperiod_tag_e )
          call h5_add(h5id, 'phi_l', o%phi_l)
          call h5_add(h5id, 'phi_r', o%phi_r)

          if (allocated(o%y))          call h5_add(h5id, 'y', o%y, lbound(o%y), ubound(o%y))
          if (allocated(o%p%amat_m_m)) call h5_add(h5id, 'amat_m_m', o%p%amat_m_m, lbound(o%p%amat_m_m), ubound(o%p%amat_m_m))
          if (allocated(o%p%amat_p_m)) call h5_add(h5id, 'amat_p_m', o%p%amat_p_m, lbound(o%p%amat_p_m), ubound(o%p%amat_p_m))
          if (allocated(o%p%source_m)) call h5_add(h5id, 'source_m', o%p%source_m, lbound(o%p%source_m), ubound(o%p%source_m))
          if (allocated(o%p%flux_m))   call h5_add(h5id, 'flux_m', o%p%flux_m, lbound(o%p%flux_m), ubound(o%p%flux_m))
          if (allocated(o%p%flux_p))   call h5_add(h5id, 'flux_p', o%p%flux_p, lbound(o%p%flux_p), ubound(o%p%flux_p))
          if (allocated(o%p%qflux))    call h5_add(h5id, 'qflux', o%p%qflux, lbound(o%p%qflux), ubound(o%p%qflux))
          if (allocated(o%p%eta_l))    call h5_add(h5id, 'eta_l', o%p%eta_l, lbound(o%p%eta_l), ubound(o%p%eta_l))
          if (allocated(o%p%eta_r))    call h5_add(h5id, 'eta_r', o%p%eta_r, lbound(o%p%eta_r), ubound(o%p%eta_r))

          call h5_add(h5id, 'eta_boundary_l', o%p%eta_boundary_l)
          call h5_add(h5id, 'eta_boundary_r', o%p%eta_boundary_r)

       end if

       if (prop_showall .eq. 0) then
          call h5_add(h5id, 'bin_split_mode', o%bin_split_mode)
       end if

       if (prop_showall .ge. 1) then
          call h5_add(h5id, 'npart',     o%p%npart)
          call h5_add(h5id, 'npass_l',   o%p%npass_l)
          call h5_add(h5id, 'npass_r',   o%p%npass_r)
          call h5_add(h5id, 'nvelocity', o%p%nvelocity)

          if (allocated(o%p%amat_p_p)) call h5_add(h5id, 'amat_p_p', o%p%amat_p_p, lbound(o%p%amat_p_p), ubound(o%p%amat_p_p))
          if (allocated(o%p%amat_m_p)) call h5_add(h5id, 'amat_m_p', o%p%amat_m_p, lbound(o%p%amat_m_p), ubound(o%p%amat_m_p))
          if (allocated(o%p%source_p)) call h5_add(h5id, 'source_p', o%p%source_p, lbound(o%p%source_p), ubound(o%p%source_p))
       end if

       call h5_close(h5id)
       
    else
       
       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_cfilename,status='replace', &
            form=prop_format,action='write')

       ! what is written for prop_showall = 1
       !    tags  : prop_start,prop_end
       !    info  : o%nr_joined ....  o%phi_r
       !    sizes : o%p%npart, o%p%npass_l, o%p%npass_r, o%p%velocity
       !    amat_p_p
       !    amat_m_m
       !    amat_p_m
       !    amat_m_p
       !    source_p
       !    source_m
       !    flux_p
       !    flux_m
       !    qflux
       !    eta

       !
       ! what is written for prop_showall > 1 (reduced for joined)
       !    tags  : prop_start,prop_end
       !    sizes : o%p%npart, o%p%npass_l, o%p%npass_r, o%p%velocity
       !    amat_p_p
       !    amat_m_p
       !    source_p


       ! tags
       WRITE(prop_unit,*) prop_start
       WRITE(prop_unit,*) prop_end

       ! info
       IF (prop_showall .EQ. 1) THEN
          WRITE(prop_unit,*) o%nr_joined
          WRITE(prop_unit,*) o%fieldpropagator_tag_s
          WRITE(prop_unit,*) o%fieldpropagator_tag_e
          WRITE(prop_unit,*) o%fieldperiod_tag_s
          WRITE(prop_unit,*) o%fieldperiod_tag_e

          if (allocated(o%y)) then
             WRITE(prop_unit,*) LBOUND(o%y,1),UBOUND(o%y,1)
             WRITE(prop_unit,*) o%y
          ELSE
             WRITE(prop_unit,*) 0,0
          END IF
          WRITE(prop_unit,*) o%phi_l
          WRITE(prop_unit,*) o%phi_r
       END IF

       ! Binarysplit stuff is not dumped / this is the only thing with prop_showall = 0
       ! It is not really used
       IF (prop_showall .EQ. 0) THEN
          WRITE(prop_unit,*) o%bin_split_mode
       END IF

       ! sizes
       IF (prop_showall .GE. 1) THEN
          WRITE(prop_unit,*) o%p%npart
          WRITE(prop_unit,*) o%p%npass_l
          WRITE(prop_unit,*) o%p%npass_r
          WRITE(prop_unit,*) o%p%nvelocity
       END IF
       ! amat_p_p
       IF (prop_showall .GE. 1) THEN
          IF (ALLOCATED(o%p%amat_p_p)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%amat_p_p,1),UBOUND(o%p%amat_p_p,1)
             WRITE(prop_unit,*) LBOUND(o%p%amat_p_p,2),UBOUND(o%p%amat_p_p,2)
             WRITE(prop_unit,*) o%p%amat_p_p
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF
       ! amat_m_m
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%amat_m_m)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%amat_m_m,1),UBOUND(o%p%amat_m_m,1)
             WRITE(prop_unit,*) LBOUND(o%p%amat_m_m,2),UBOUND(o%p%amat_m_m,2)
             WRITE(prop_unit,*) o%p%amat_m_m
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF
       ! amat_p_m
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%amat_p_m)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%amat_p_m,1),UBOUND(o%p%amat_p_m,1)
             WRITE(prop_unit,*) LBOUND(o%p%amat_p_m,2),UBOUND(o%p%amat_p_m,2)
             WRITE(prop_unit,*) o%p%amat_p_m
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF
       ! amat_m_p
       IF (prop_showall .GE. 1) THEN
          IF (ALLOCATED(o%p%amat_m_p)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%amat_m_p,1),UBOUND(o%p%amat_m_p,1)
             WRITE(prop_unit,*) LBOUND(o%p%amat_m_p,2),UBOUND(o%p%amat_m_p,2)
             WRITE(prop_unit,*) o%p%amat_m_p
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF

       ! source_p
       IF (prop_showall .GE. 1) THEN
          IF (ALLOCATED(o%p%source_p)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%source_p,1),UBOUND(o%p%source_p,1)
             WRITE(prop_unit,*) LBOUND(o%p%source_p,2),UBOUND(o%p%source_p,2)
             WRITE(prop_unit,*) o%p%source_p
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF
       ! source_m
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%source_m)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%source_m,1),UBOUND(o%p%source_m,1)
             WRITE(prop_unit,*) LBOUND(o%p%source_m,2),UBOUND(o%p%source_m,2)
             WRITE(prop_unit,*) o%p%source_m
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF


       ! flux_p
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%flux_p)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%flux_p,1),UBOUND(o%p%flux_p,1)
             WRITE(prop_unit,*) LBOUND(o%p%flux_p,2),UBOUND(o%p%flux_p,2)
             WRITE(prop_unit,*) o%p%flux_p
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF
       ! flux_m
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%flux_m)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%flux_m,1),UBOUND(o%p%flux_m,1)
             WRITE(prop_unit,*) LBOUND(o%p%flux_m,2),UBOUND(o%p%flux_m,2)
             WRITE(prop_unit,*) o%p%flux_m
          ELSE
             WRITE(prop_unit,*) 0,0
             WRITE(prop_unit,*) 0,0
          END IF
       END IF

       ! qflux
       IF (prop_showall .EQ. 1) THEN
          WRITE(prop_unit,*) o%p%qflux
       END IF


       ! eta
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%eta_l)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%eta_l,1),UBOUND(o%p%eta_l,1)
             WRITE(prop_unit,*) o%p%eta_l
          ELSE
             WRITE(prop_unit,*) 0,0
          END IF
          IF (ALLOCATED(o%p%eta_r)) THEN
             WRITE(prop_unit,*) LBOUND(o%p%eta_r,1),UBOUND(o%p%eta_r,1)
             WRITE(prop_unit,*) o%p%eta_r
          ELSE
             WRITE(prop_unit,*) 0,0
          END IF
          WRITE(prop_unit,*) o%p%eta_boundary_l
          WRITE(prop_unit,*) o%p%eta_boundary_r
       END IF

       CLOSE(unit=prop_unit)

    end if


  END SUBROUTINE write_propagator_cont
  ! ---------------------------------------------------------------------------

  SUBROUTINE write_prop_bound_cont(o,n,prop_type)
    ! writes the conversion matrices 
    !   o%p%cmat (forward) and
    !   n%p%cmat (backward) 
    ! between two propagators
    !
    ! pointer o - old, left
    ! pointer n - new, right
    TYPE(propagator), POINTER  :: o,n

    INTEGER, INTENT(in) :: prop_type
    INTEGER :: prop_bound
    INTEGER :: prop_left
    INTEGER :: prop_right

    character(len=256) :: prop_cfilename_h5

    integer(SIZE_T) :: obj_count

    
    prop_bound = 1
    IF (prop_type .EQ. 1) THEN
       prop_right = n%fieldperiod_tag_s
       !prop_left  = o%fieldperiod_tag_e
       prop_left  = prop_right - 1
    ELSEIF (prop_type .EQ. 3) THEN
       prop_right = n%fieldpropagator_tag_s
       !prop_left  = o%fieldperiod_tag_e
       prop_left  = prop_right - 1
    ELSE
       PRINT *, 'Propagator Writing: prop_type not implemented: ',prop_type
       RETURN
    END IF

    CALL filename_propagator(prop_type,prop_bound,prop_left,prop_right)

    if (prop_fileformat .eq. 1) then
       
       write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))

       call h5_create(prop_cfilename_h5, h5id)

       call h5_add(h5id, 'fieldpropagator_tag_left',  n%fieldpropagator_tag_s - 1)
       call h5_add(h5id, 'fieldpropagator_tag_right', n%fieldpropagator_tag_s)
       call h5_add(h5id, 'fieldperiod_tag_left',      n%fieldperiod_tag_s - 1)
       call h5_add(h5id, 'fieldperiod_tag_right',     n%fieldperiod_tag_s)

       if (allocated(o%p%cmat)) call h5_add(h5id, 'c_forward',  o%p%cmat, lbound(o%p%cmat), ubound(o%p%cmat))
       if (allocated(n%p%cmat)) call h5_add(h5id, 'c_backward', n%p%cmat, lbound(n%p%cmat), ubound(n%p%cmat))

       call h5_close(h5id)

       !call h5fget_obj_count_f(H5F_OBJ_ALL_F, H5F_OBJ_ALL_F, obj_count, h5error)
       !write (*,*) "Open HDF5 objects (all): ", obj_count, h5error
       !call h5fget_obj_count_f(H5F_OBJ_ALL_F, H5F_OBJ_DATASET_F, obj_count, h5error)
       !write (*,*) "Open HDF5 objects (dataset): ", obj_count, h5error
       !call h5fget_obj_count_f(H5F_OBJ_ALL_F, H5F_OBJ_GROUP_F, obj_count, h5error)
       !write (*,*) "Open HDF5 objects (groups): ", obj_count, h5error
       !call h5fget_obj_count_f(H5F_OBJ_ALL_F, H5F_OBJ_DATATYPE_F, obj_count, h5error)
       !write (*,*) "Open HDF5 objects (datatypes): ", obj_count, h5error


    else
       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_cfilename,status='replace', &
            form=prop_format,action='write')
       ! tags
       WRITE(prop_unit,*) n%fieldpropagator_tag_s - 1
       WRITE(prop_unit,*) n%fieldpropagator_tag_s
       WRITE(prop_unit,*) n%fieldperiod_tag_s - 1
       WRITE(prop_unit,*) n%fieldperiod_tag_s
       ! forward
       IF (ALLOCATED(o%p%cmat)) THEN
          WRITE(prop_unit,*) LBOUND(o%p%cmat,1),UBOUND(o%p%cmat,1)
          WRITE(prop_unit,*) LBOUND(o%p%cmat,2),UBOUND(o%p%cmat,2)
          WRITE(prop_unit,*) o%p%cmat
       ELSE
          WRITE(prop_unit,*) 0,0
          WRITE(prop_unit,*) 0,0
       END IF
       ! backward
       IF (ALLOCATED(n%p%cmat)) THEN
          WRITE(prop_unit,*) LBOUND(n%p%cmat,1),UBOUND(n%p%cmat,1)
          WRITE(prop_unit,*) LBOUND(n%p%cmat,2),UBOUND(n%p%cmat,2)
          WRITE(prop_unit,*) n%p%cmat    
       ELSE
          WRITE(prop_unit,*) 0,0
          WRITE(prop_unit,*) 0,0
       END IF

       CLOSE(unit=prop_unit)

    end if
    
  END SUBROUTINE write_prop_bound_cont
  ! ---------------------------------------------------------------------------

  subroutine write_binarysplit_side_h5(h5id_binsplit, grpname, binsplit)
    integer(HID_T) :: h5id_binsplit
    character(len=*) :: grpname
    type(binarysplit) :: binsplit

    integer(HID_T) :: h5id_grp

    call h5_define_group(h5id_binsplit, grpname, h5id_grp)

    call h5_add(h5id_grp, 'n_ori', binsplit%n_ori)
    call h5_add(h5id_grp, 'n_split', binsplit%n_split)

    !write (*,*) "In write_binarysplit_side_h5", allocated(binsplit%x_ori_poi), binsplit%x_ori_poi
    !stop
    
    call h5_add(h5id_grp, 'x_ori_bin', binsplit%x_ori_bin, lbound(binsplit%x_ori_bin), ubound(binsplit%x_ori_bin))
    call h5_add(h5id_grp, 'x_ori_poi', binsplit%x_ori_poi, lbound(binsplit%x_ori_poi), ubound(binsplit%x_ori_poi))
    call h5_add(h5id_grp, 'x_poi', binsplit%x_poi, lbound(binsplit%x_poi), ubound(binsplit%x_poi))
    call h5_add(h5id_grp, 'x_split', binsplit%x_split, lbound( binsplit%x_split), ubound(binsplit%x_split))
    call h5_add(h5id_grp, 'x_pos', binsplit%x_pos, lbound(binsplit%x_pos), ubound(binsplit%x_pos))
    call h5_add(h5id_grp, 'x', binsplit%x, lbound(binsplit%x), ubound(binsplit%x))
    call h5_add(h5id_grp, 'y', binsplit%y, lbound(binsplit%y), ubound(binsplit%y))
    call h5_add(h5id_grp, 'int', binsplit%int, lbound(binsplit%int), ubound(binsplit%int))
    call h5_add(h5id_grp, 'err', binsplit%err, lbound(binsplit%err), ubound(binsplit%err))

    call h5_close_group(h5id_grp)

  end subroutine write_binarysplit_side_h5

  SUBROUTINE write_binarysplit_cont(o)
    ! writes the content of a binarysplit, which is specified in pointer o
    TYPE(propagator), POINTER  :: o

    INTEGER :: prop_type

    INTEGER :: prop_bound
    INTEGER :: prop_start
    INTEGER :: prop_end

    integer :: ncid_binarysplit
    character(len=100) :: prop_cfilename_h5

    prop_bound = 0
    prop_type = 6
    prop_start = o%fieldpropagator_tag_s
    prop_end   = o%fieldpropagator_tag_e

    CALL filename_propagator(prop_type,prop_bound,prop_start,prop_end)

    if (prop_fileformat .eq. 1) then

       write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))

       call h5_create(prop_cfilename_h5, h5id)
       call h5_add(h5id, 'bin_split_mode', o%bin_split_mode)

       call write_binarysplit_side_h5(h5id, 'left',  o%eta_bs_l)
       call write_binarysplit_side_h5(h5id, 'right', o%eta_bs_r)

       call h5_close(h5id)

    else

       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_cfilename,status='replace', &
            form=prop_format,action='write')

       WRITE(prop_unit,*) o%bin_split_mode

       ! binarysplit left
       WRITE(prop_unit,*) o%eta_bs_l%n_ori
       WRITE(prop_unit,*) o%eta_bs_l%n_split
       ! x_ori_bin
       IF (ALLOCATED(o%eta_bs_l%x_ori_bin)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_ori_bin,1),UBOUND(o%eta_bs_l%x_ori_bin,1)
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_ori_bin,2),UBOUND(o%eta_bs_l%x_ori_bin,2)
          WRITE(prop_unit,*) o%eta_bs_l%x_ori_bin
       ELSE
          WRITE(prop_unit,*) 0,0
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_ori_poi
       IF (ALLOCATED(o%eta_bs_l%x_ori_poi)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_ori_poi,1),UBOUND(o%eta_bs_l%x_ori_poi,1)
          WRITE(prop_unit,*) o%eta_bs_l%x_ori_poi
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_poi
       IF (ALLOCATED(o%eta_bs_l%x_poi)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_poi,1),UBOUND(o%eta_bs_l%x_poi,1)
          WRITE(prop_unit,*) o%eta_bs_l%x_poi
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_split
       IF (ALLOCATED(o%eta_bs_l%x_split)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_split,1),UBOUND(o%eta_bs_l%x_split,1)
          WRITE(prop_unit,*) o%eta_bs_l%x_split
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_pos
       IF (ALLOCATED(o%eta_bs_l%x_pos)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x_pos,1),UBOUND(o%eta_bs_l%x_pos,1)
          WRITE(prop_unit,*) o%eta_bs_l%x_pos
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x
       IF (ALLOCATED(o%eta_bs_l%x)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%x,1),UBOUND(o%eta_bs_l%x,1)
          WRITE(prop_unit,*) o%eta_bs_l%x
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! y
       IF (ALLOCATED(o%eta_bs_l%y)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%y,1),UBOUND(o%eta_bs_l%y,1)
          WRITE(prop_unit,*) o%eta_bs_l%y
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! int
       IF (ALLOCATED(o%eta_bs_l%int)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%int,1),UBOUND(o%eta_bs_l%int,1)
          WRITE(prop_unit,*) o%eta_bs_l%int
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! err
       IF (ALLOCATED(o%eta_bs_l%err)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_l%err,1),UBOUND(o%eta_bs_l%err,1)
          WRITE(prop_unit,*) o%eta_bs_l%err
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF

       ! binarysplit right
       WRITE(prop_unit,*) o%eta_bs_r%n_ori
       WRITE(prop_unit,*) o%eta_bs_r%n_split
       ! x_ori_bin
       IF (ALLOCATED(o%eta_bs_l%x_ori_bin)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_ori_bin,1),UBOUND(o%eta_bs_r%x_ori_bin,1)
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_ori_bin,2),UBOUND(o%eta_bs_r%x_ori_bin,2)
          WRITE(prop_unit,*) o%eta_bs_r%x_ori_bin
       ELSE
          WRITE(prop_unit,*) 0,0
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_ori_poi
       IF (ALLOCATED(o%eta_bs_r%x_ori_poi)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_ori_poi,1),UBOUND(o%eta_bs_r%x_ori_poi,1)
          WRITE(prop_unit,*) o%eta_bs_r%x_ori_poi
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_poi
       IF (ALLOCATED(o%eta_bs_r%x_poi)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_poi,1),UBOUND(o%eta_bs_r%x_poi,1)
          WRITE(prop_unit,*) o%eta_bs_r%x_poi
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_split
       IF (ALLOCATED(o%eta_bs_r%x_split)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_split,1),UBOUND(o%eta_bs_r%x_split,1)
          WRITE(prop_unit,*) o%eta_bs_r%x_split
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x_pos
       IF (ALLOCATED(o%eta_bs_r%x_pos)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x_pos,1),UBOUND(o%eta_bs_r%x_pos,1)
          WRITE(prop_unit,*) o%eta_bs_r%x_pos
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! x
       IF (ALLOCATED(o%eta_bs_r%x)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%x,1),UBOUND(o%eta_bs_r%x,1)
          WRITE(prop_unit,*) o%eta_bs_r%x
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! y
       IF (ALLOCATED(o%eta_bs_r%y)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%y,1),UBOUND(o%eta_bs_r%y,1)
          WRITE(prop_unit,*) o%eta_bs_r%y
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! int
       IF (ALLOCATED(o%eta_bs_r%int)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%int,1),UBOUND(o%eta_bs_r%int,1)
          WRITE(prop_unit,*) o%eta_bs_r%int
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF
       ! err
       IF (ALLOCATED(o%eta_bs_r%err)) THEN
          WRITE(prop_unit,*) LBOUND(o%eta_bs_r%err,1),UBOUND(o%eta_bs_r%err,1)
          WRITE(prop_unit,*) o%eta_bs_r%err
       ELSE
          WRITE(prop_unit,*) 0,0
       END IF

       close(unit=prop_unit)

    end if
    
  end SUBROUTINE write_binarysplit_cont
  ! ---------------------------------------------------------------------------

  SUBROUTINE read_propagator_cont(o,prop_type,prop_start,prop_end,prop_showall_in)
    !
    ! reads the content of a propagator 
    !
    TYPE(propagator), POINTER  :: o
    INTEGER, INTENT(in), OPTIONAL :: prop_showall_in

    INTEGER, INTENT(in) :: prop_type
    INTEGER, INTENT(in) :: prop_start
    INTEGER, INTENT(in) :: prop_end

    INTEGER :: prop_bound
    INTEGER :: lb1,ub1
    INTEGER :: lb2,ub2
    INTEGER :: dummy

    INTEGER :: prop_showall
    
    IF (PRESENT(prop_showall_in)) THEN
       prop_showall = prop_showall_in
    ELSE
       prop_showall = 1
    END IF

    prop_bound = 0
    call filename_propagator(prop_type,prop_bound,prop_start,prop_end)

    if (prop_fileformat .eq. 1) then
       call h5_open(prop_cfilename, h5id)
       
       if (prop_showall .eq. 1) then
          call h5_get(h5id, 'nr_joined', o%nr_joined)
          call h5_get(h5id, 'fieldpropagator_tag_s', o%fieldpropagator_tag_s)
          call h5_get(h5id, 'fieldpropagator_tag_e', o%fieldpropagator_tag_e)
          call h5_get(h5id, 'fieldperiod_tag_s', o%fieldperiod_tag_s)
          call h5_get(h5id, 'fieldperiod_tag_e', o%fieldperiod_tag_e)

          call h5_get_bounds(h5id, 'y', lb1, ub1)
          if (ub1 .gt. 0) then
             if (allocated(o%y)) deallocate(o%y)
             allocate(o%y(lb1:ub1))
             call h5_get(h5id, 'y', o%y)
          end if

          call h5_get(h5id, 'phi_l', o%phi_l)
          call h5_get(h5id, 'phi_r', o%phi_r)
       end if

       if (prop_showall .eq. 0) then
          call h5_get(h5id, 'bin_split_mode', o%bin_split_mode)
       end if

       if (prop_showall .ge. 1) then
          call h5_get(h5id, 'npart', o%p%npart)
          call h5_get(h5id, 'npass_l', o%p%npass_l)
          call h5_get(h5id, 'npass_r', o%p%npass_r)
          call h5_get(h5id, 'nvelocity', o%p%nvelocity)
       end if

       if (prop_showall .ge. 1) then
          call h5_get_bounds(h5id, 'amat_p_p', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%amat_p_p)) deallocate(o%p%amat_p_p)
             allocate(o%p%amat_p_p(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'amat_p_p',  o%p%amat_p_p)
          end if
          
          call h5_get_bounds(h5id, 'amat_m_p', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%amat_m_p)) deallocate(o%p%amat_m_p)
             allocate(o%p%amat_m_p(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'amat_m_p',  o%p%amat_m_p)
          end if
       end if
       
       if (prop_showall .eq. 1) then
          call h5_get_bounds(h5id, 'amat_m_m', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%amat_m_m)) deallocate(o%p%amat_m_m)
             allocate(o%p%amat_m_m(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'amat_m_m',  o%p%amat_m_m)
          end if

          call h5_get_bounds(h5id, 'amat_p_m', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%amat_p_m)) deallocate(o%p%amat_p_m)
             allocate(o%p%amat_p_m(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'amat_p_m',  o%p%amat_p_m)
          end if
       end if

       if (prop_showall .ge. 1) then
          call h5_get_bounds(h5id, 'source_p', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%source_p)) deallocate(o%p%source_p)
             allocate(o%p%source_p(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'source_p',  o%p%source_p)
          end if
       end if

       if (prop_showall .eq. 1) then
          call h5_get_bounds(h5id, 'source_m', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%source_m)) deallocate(o%p%source_m)
             allocate(o%p%source_m(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'source_m',  o%p%source_m)
          end if

          call h5_get_bounds(h5id, 'flux_p', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%flux_p)) deallocate(o%p%flux_p)
             allocate(o%p%flux_p(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'flux_p',  o%p%flux_p)
          end if
          
          call h5_get_bounds(h5id, 'flux_m', lb1, lb2, ub1, ub2)
          if (ub1 .gt. 0 .and. ub2 .gt. 0) then
             if (allocated(o%p%flux_m)) deallocate(o%p%flux_m)
             allocate(o%p%flux_m(lb1:ub1,lb2:ub2))
             call h5_get(h5id, 'flux_m',  o%p%flux_m)
          end if

          call h5_get_bounds(h5id, 'qflux', lb1, lb2, ub1, ub2)
          if (allocated(o%p%qflux)) deallocate(o%p%qflux)
          allocate(o%p%qflux(lb1:ub1,lb2:ub2))
          call h5_get(h5id, 'qflux',  o%p%qflux)

          call h5_get_bounds(h5id, 'eta_l', lb1, ub1)
          if (ub1 .gt. 0) then
             if (allocated(o%p%eta_l)) deallocate(o%p%eta_l)
             allocate(o%p%eta_l(lb1:ub1))
             call h5_get(h5id, 'eta_l', o%p%eta_l)           
          end if
          
          call h5_get_bounds(h5id, 'eta_r', lb1, ub1)
          if (ub1 .gt. 0) then
             if (allocated(o%p%eta_r)) deallocate(o%p%eta_r)
             allocate(o%p%eta_r(lb1:ub1))
             call h5_get(h5id, 'eta_r', o%p%eta_r)           
          end if

          call h5_get(h5id, 'eta_boundary_l', o%p%eta_boundary_l)
          call h5_get(h5id, 'eta_boundary_r', o%p%eta_boundary_r)
          
       end if

       !write (*,*) "dims:", lbound(o%p%amat_p_p), ubound(o%p%amat_p_p)
       
       call h5_close(h5id)
       
    else

       CALL unit_propagator

       !PRINT *, prop_cfilename

       OPEN(unit=prop_unit,file=prop_cfilename,status='old', &
            form=prop_format,action='read')

       ! tags
       READ(prop_unit,*) dummy
       READ(prop_unit,*) dummy

       ! info
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) o%nr_joined
          READ(prop_unit,*) o%fieldpropagator_tag_s
          READ(prop_unit,*) o%fieldpropagator_tag_e
          READ(prop_unit,*) o%fieldperiod_tag_s
          READ(prop_unit,*) o%fieldperiod_tag_e

          READ(prop_unit,*) lb1,ub1
          IF (ub1 .GT. 0) THEN
             IF (ALLOCATED(o%y)) DEALLOCATE(o%y)
             ALLOCATE(o%y(lb1:ub1))
             READ(prop_unit,*) o%y
          END IF
          READ(prop_unit,*) o%phi_l
          READ(prop_unit,*) o%phi_r
       END IF

       ! Binarysplit stuff is not dumped
       IF (prop_showall .EQ. 0) THEN
          READ(prop_unit,*) o%bin_split_mode
       END IF

       ! sizes
       IF (prop_showall .GE. 1) THEN
          READ(prop_unit,*) o%p%npart
          READ(prop_unit,*) o%p%npass_l
          READ(prop_unit,*) o%p%npass_r
          READ(prop_unit,*) o%p%nvelocity
       END IF

       ! amat_p_p
       IF (prop_showall .GE. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%amat_p_p)) DEALLOCATE(o%p%amat_p_p)
             ALLOCATE(o%p%amat_p_p(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%amat_p_p
          END IF
       END IF
       ! amat_m_m
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%amat_m_m)) DEALLOCATE(o%p%amat_m_m)
             ALLOCATE(o%p%amat_m_m(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%amat_m_m
          END IF
       END IF
       ! amat_p_m
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%amat_p_m)) DEALLOCATE(o%p%amat_p_m)
             ALLOCATE(o%p%amat_p_m(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%amat_p_m
          END IF
       END IF
       ! amat_m_p
       IF (prop_showall .GE. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%amat_m_p)) DEALLOCATE(o%p%amat_m_p)
             ALLOCATE(o%p%amat_m_p(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%amat_m_p
          END IF
       END IF

       ! source_p
       IF (prop_showall .GE. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%source_p)) DEALLOCATE(o%p%source_p)
             ALLOCATE(o%p%source_p(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%source_p
          END IF
       END IF
       ! source_m
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%source_m)) DEALLOCATE(o%p%source_m)
             ALLOCATE(o%p%source_m(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%source_m
          END IF
       END IF

       ! flux_p
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%flux_p)) DEALLOCATE(o%p%flux_p)
             ALLOCATE(o%p%flux_p(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%flux_p
          END IF
       END IF
       ! flux_m
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          READ(prop_unit,*) lb2,ub2
          IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
             IF (ALLOCATED(o%p%flux_m)) DEALLOCATE(o%p%flux_m)
             ALLOCATE(o%p%flux_m(lb1:ub1,lb2:ub2))
             READ(prop_unit,*) o%p%flux_m
          END IF
       END IF

       ! qflux - Winny not fully ok
       IF (prop_showall .EQ. 1) THEN
          IF (ALLOCATED(o%p%qflux)) DEALLOCATE(o%p%qflux)
          ALLOCATE(o%p%qflux(3,3))
          READ(prop_unit,*) o%p%qflux
       END IF

       ! eta
       IF (prop_showall .EQ. 1) THEN
          READ(prop_unit,*) lb1,ub1
          IF (ub1 .GT. 0) THEN
             IF (ALLOCATED(o%p%eta_l)) DEALLOCATE(o%p%eta_l)
             ALLOCATE(o%p%eta_l(lb1:ub1))
             READ(prop_unit,*) o%p%eta_l
          END IF
          READ(prop_unit,*) lb1,ub1
          IF (ub1 .GT. 0) THEN
             IF (ALLOCATED(o%p%eta_r)) DEALLOCATE(o%p%eta_r)
             ALLOCATE(o%p%eta_r(lb1:ub1))
             READ(prop_unit,*) o%p%eta_r
          END IF
          READ(prop_unit,*) o%p%eta_boundary_l
          READ(prop_unit,*) o%p%eta_boundary_r
       END IF

       close(unit=prop_unit)
    end if
  END SUBROUTINE read_propagator_cont
  ! ---------------------------------------------------------------------------

  SUBROUTINE read_prop_bound_cont(b,prop_type,prop_left,prop_right)
    !
    ! reads the content of a boundary between propagators
    !
    TYPE(prop_boundary)  :: b
    
    INTEGER, INTENT(in) :: prop_type
    INTEGER, INTENT(in) :: prop_left
    INTEGER, INTENT(in) :: prop_right

    INTEGER :: prop_bound
    INTEGER :: lb1,ub1
    INTEGER :: lb2,ub2

    prop_bound = 1

    CALL filename_propagator(prop_type,prop_bound,prop_left,prop_right)

    if (prop_fileformat .eq. 1) then

       call h5_open(prop_cfilename, h5id)
       
       call h5_get(h5id, 'fieldpropagator_tag_left', b%fieldpropagator_tag_left)
       call h5_get(h5id, 'fieldpropagator_tag_right', b%fieldpropagator_tag_right)
       call h5_get(h5id, 'fieldperiod_tag_left', b%fieldperiod_tag_left)
       call h5_get(h5id, 'fieldperiod_tag_right', b%fieldperiod_tag_right)

       call h5_get_bounds(h5id, 'c_forward', lb1, lb2, ub1, ub2)
       if (ub1 .gt. 0 .and. ub2 .gt. 0) then
          if (allocated(b%c_forward)) deallocate(b%c_forward)
          allocate(b%c_forward(lb1:ub1,lb2:ub2))
          call h5_get(h5id, 'c_forward', b%c_forward)
       end if

       call h5_get_bounds(h5id, 'c_backward', lb1, lb2, ub1, ub2)
       if (ub1 .gt. 0 .and. ub2 .gt. 0) then
          if (allocated(b%c_backward)) deallocate(b%c_backward)
          allocate(b%c_backward(lb1:ub1,lb2:ub2))
          call h5_get(h5id, 'c_backward', b%c_backward)
       end if
       
       call h5_close(h5id)
       
    else

       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_cfilename,status='old', &
            form=prop_format,action='read')
       ! tags
       READ(prop_unit,*) b%fieldpropagator_tag_left
       READ(prop_unit,*) b%fieldpropagator_tag_right
       READ(prop_unit,*) b%fieldperiod_tag_left
       READ(prop_unit,*) b%fieldperiod_tag_right
       ! forward
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
          IF (ALLOCATED(b%c_forward)) DEALLOCATE(b%c_forward)
          ALLOCATE(b%c_forward(lb1:ub1,lb2:ub2))
          READ(prop_unit,*) b%c_forward
       END IF
       ! backward
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ub1 .GT. 0 .AND. ub2 .GT. 0) THEN
          IF (ALLOCATED(b%c_backward)) DEALLOCATE(b%c_backward)
          ALLOCATE(b%c_backward(lb1:ub1,lb2:ub2))
          READ(prop_unit,*) b%c_backward
       END IF

       CLOSE(unit=prop_unit)

    end if
  
  END SUBROUTINE read_prop_bound_cont
  ! ---------------------------------------------------------------------------

  subroutine read_binarysplit_side_h5(h5id, grpname, binsplit)
    integer(HID_T) :: h5id
    character(len=*) :: grpname
    type(binarysplit), intent(inout) :: binsplit

    integer(HID_T) :: h5id_grp
    integer :: lb1, ub1, lb2, ub2

    call h5_open_group(h5id, grpname, h5id_grp)

    call h5_get(h5id_grp, 'n_ori', binsplit%n_ori)
    call h5_get(h5id_grp, 'n_split', binsplit%n_split)
    
    call h5_get_bounds(h5id_grp, 'x_ori_bin', lb1, lb2, ub1, ub2)
    if (ub1 .gt. lb1 .or. ub2 .gt. lb2) then
       if (allocated(binsplit%x_ori_bin)) deallocate(binsplit%x_ori_bin)
       allocate(binsplit%x_ori_bin(lb1:ub1,lb2:ub2))
       call h5_get(h5id_grp, 'x_ori_bin', binsplit%x_ori_bin)
    end if
    
    call h5_get_bounds(h5id_grp, 'x_ori_poi', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%x_ori_poi)) deallocate(binsplit%x_ori_poi)
       allocate(binsplit%x_ori_poi(lb1:ub1))
       call h5_get(h5id_grp, 'x_ori_poi', binsplit%x_ori_poi)
    end if

    call h5_get_bounds(h5id_grp, 'x_poi', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%x_poi)) deallocate(binsplit%x_poi)
       allocate(binsplit%x_poi(lb1:ub1))
       call h5_get(h5id_grp, 'x_poi', binsplit%x_poi)
    end if

     call h5_get_bounds(h5id_grp, 'x_split', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%x_split)) deallocate(binsplit%x_split)
       allocate(binsplit%x_split(lb1:ub1))
       call h5_get(h5id_grp, 'x_split', binsplit%x_split)
    end if

   call h5_get_bounds(h5id_grp, 'x_pos', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%x_pos)) deallocate(binsplit%x_pos)
       allocate(binsplit%x_pos(lb1:ub1))
       call h5_get(h5id_grp, 'x_pos', binsplit%x_pos)
    end if
    
    call h5_get_bounds(h5id_grp, 'x', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%x)) deallocate(binsplit%x)
       allocate(binsplit%x(lb1:ub1))
       call h5_get(h5id_grp, 'x', binsplit%x)
    end if

    call h5_get_bounds(h5id_grp, 'y', lb1, ub1)
    if (ub1 .gt. 0) then
       if (allocated(binsplit%y)) deallocate(binsplit%y)
       allocate(binsplit%y(lb1:ub1))
       call h5_get(h5id_grp, 'y', binsplit%y)
    end if
 
    call h5_get_bounds(h5id_grp, 'int', lb1, ub1)   
    if (ub1 .gt. 0) then
       if (allocated(binsplit%int)) deallocate(binsplit%int)
       allocate(binsplit%int(lb1:ub1))
       call h5_get(h5id_grp, 'int', binsplit%int)
    end if

    call h5_get_bounds(h5id_grp, 'err', lb1, ub1)   
    if (ub1 .gt. 0) then
       if (allocated(binsplit%err)) deallocate(binsplit%err)
       allocate(binsplit%err(lb1:ub1))
       call h5_get(h5id_grp, 'err', binsplit%err)
    end if

    call h5_close_group(h5id_grp)

    !write (*,*) "Reconstruct binsplit", binsplit%x_pos, 'AA', lbound(binsplit%x_pos)
    
  end subroutine read_binarysplit_side_h5
  

  subroutine read_binarysplit_cont(o)
    ! reads the  binarysplit content of a propagator, which is specified in pointer o
    TYPE(propagator), POINTER  :: o

    INTEGER :: prop_type

    INTEGER :: prop_bound
    INTEGER :: prop_start
    INTEGER :: prop_end

    integer :: lb1,ub1,lb2,ub2 

    prop_bound = 0
    prop_type = 6
    prop_start = o%fieldpropagator_tag_s
    prop_end   = o%fieldpropagator_tag_e


    call filename_propagator(prop_type,prop_bound,prop_start,prop_end)

    if (prop_fileformat .eq. 1) then

       call h5_open(prop_cfilename, h5id)

       call h5_get(h5id, 'bin_split_mode', o%bin_split_mode)
       call read_binarysplit_side_h5(h5id, 'left', o%eta_bs_l)
       call read_binarysplit_side_h5(h5id, 'right', o%eta_bs_r)
       
       call h5_close(h5id)
    
    else

       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_cfilename,status='old', &
            form=prop_format,action='read')
       
       READ(prop_unit,*) o%bin_split_mode

       ! binarysplit left
       READ(prop_unit,*) o%eta_bs_l%n_ori
       READ(prop_unit,*) o%eta_bs_l%n_split
       ! x_ori_bin
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ub1 .GT. lb1 .or. ub2 .GT. lb2) THEN
          IF (ALLOCATED(o%eta_bs_l%x_ori_bin)) DEALLOCATE(o%eta_bs_l%x_ori_bin)
          ALLOCATE(o%eta_bs_l%x_ori_bin(lb1:ub1,lb2:ub2))
          READ(prop_unit,*) o%eta_bs_l%x_ori_bin
       END IF
       ! x_ori_poi
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%x_ori_poi)) DEALLOCATE(o%eta_bs_l%x_ori_poi)
          ALLOCATE(o%eta_bs_l%x_ori_poi(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%x_ori_poi
       END IF
       ! x_poi
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%x_poi)) DEALLOCATE(o%eta_bs_l%x_poi)
          ALLOCATE(o%eta_bs_l%x_poi(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%x_poi
       END IF
       ! x_split
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%x_split)) DEALLOCATE(o%eta_bs_l%x_split)
          ALLOCATE(o%eta_bs_l%x_split(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%x_split
       END IF
       ! x_pos
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%x_pos)) DEALLOCATE(o%eta_bs_l%x_pos)
          ALLOCATE(o%eta_bs_l%x_pos(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%x_pos
       END IF
       ! x
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%x)) DEALLOCATE(o%eta_bs_l%x)
          ALLOCATE(o%eta_bs_l%x(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%x
       END IF
       ! y
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%y)) DEALLOCATE(o%eta_bs_l%y)
          ALLOCATE(o%eta_bs_l%y(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%y
       END IF
       ! int
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%int)) DEALLOCATE(o%eta_bs_l%int)
          ALLOCATE(o%eta_bs_l%int(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%int
       END IF
       ! err
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_l%err)) DEALLOCATE(o%eta_bs_l%err)
          ALLOCATE(o%eta_bs_l%err(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_l%err
       END IF

       ! binarysplit right
       READ(prop_unit,*) o%eta_bs_r%n_ori
       READ(prop_unit,*) o%eta_bs_r%n_split
       ! x_ori_bin
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ub1 .GT. lb1 .or. ub2 .GT. lb2) THEN
          IF (ALLOCATED(o%eta_bs_r%x_ori_bin)) DEALLOCATE(o%eta_bs_r%x_ori_bin)
          ALLOCATE(o%eta_bs_r%x_ori_bin(lb1:ub1,lb2:ub2))
          READ(prop_unit,*) o%eta_bs_r%x_ori_bin
       END IF
       ! x_ori_poi
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%x_ori_poi)) DEALLOCATE(o%eta_bs_r%x_ori_poi)
          ALLOCATE(o%eta_bs_r%x_ori_poi(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%x_ori_poi
       END IF
       ! x_poi
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%x_poi)) DEALLOCATE(o%eta_bs_r%x_poi)
          ALLOCATE(o%eta_bs_r%x_poi(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%x_poi
       END IF
       ! x_split
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%x_split)) DEALLOCATE(o%eta_bs_r%x_split)
          ALLOCATE(o%eta_bs_r%x_split(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%x_split
       END IF
       ! x_pos
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%x_pos)) DEALLOCATE(o%eta_bs_r%x_pos)
          ALLOCATE(o%eta_bs_r%x_pos(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%x_pos
       END IF
       ! x
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%x)) DEALLOCATE(o%eta_bs_r%x)
          ALLOCATE(o%eta_bs_r%x(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%x
       END IF
       ! y
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%y)) DEALLOCATE(o%eta_bs_r%y)
          ALLOCATE(o%eta_bs_r%y(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%y
       END IF
       ! int
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%int)) DEALLOCATE(o%eta_bs_r%int)
          ALLOCATE(o%eta_bs_r%int(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%int
       END IF
       ! err
       READ(prop_unit,*) lb1,ub1
       IF (ub1 .GT. 0) THEN
          IF (ALLOCATED(o%eta_bs_r%err)) DEALLOCATE(o%eta_bs_r%err)
          ALLOCATE(o%eta_bs_r%err(lb1:ub1))
          READ(prop_unit,*) o%eta_bs_r%err
       END IF

       close(unit=prop_unit)

    end if

    
  end SUBROUTINE read_binarysplit_cont
  ! ---------------------------------------------------------------------------

  SUBROUTINE read_prop_recon_cont(tag)
    ! reads fluxes for a given propagator (from results file)
    INTEGER, INTENT(in) :: tag
    INTEGER :: dummy,lb1,ub1,lb2,ub2

    ! 5: result
    ! 0: no boundary
    CALL filename_propagator(5,0,tag,tag)

    if (prop_fileformat .eq. 1) then

       call h5_open(prop_cfilename, h5id)

       call h5_get_bounds(h5id, 'flux_mr', lb1, lb2, ub1, ub2)
       if (allocated(flux_mr)) deallocate(flux_mr)
       allocate(flux_mr(lb1:ub1,lb2:ub2))
       call h5_get(h5id, 'flux_mr', flux_mr)

       call h5_get_bounds(h5id, 'flux_pl', lb1, lb2, ub1, ub2)
       if (allocated(flux_pl)) deallocate(flux_pl)
       allocate(flux_pl(lb1:ub1,lb2:ub2))
       call h5_get(h5id, 'flux_pl', flux_pl)      
       
       call h5_close(h5id)
       
    else
       OPEN(unit=prop_unit,file=prop_cfilename,status='old', &
            form=prop_format,action='read')
       READ(prop_unit,*) dummy
       ! flux_mr for tag
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ALLOCATED(flux_mr)) DEALLOCATE(flux_mr)
       ALLOCATE(flux_mr(lb1:ub1,lb2:ub2))
       READ(prop_unit,*) flux_mr
       ! flux_pl for tag
       READ(prop_unit,*) lb1,ub1
       READ(prop_unit,*) lb2,ub2
       IF (ALLOCATED(flux_pl)) DEALLOCATE(flux_pl)
       ALLOCATE(flux_pl(lb1:ub1,lb2:ub2))
       READ(prop_unit,*) flux_pl
       CLOSE(unit=prop_unit)
    end if
  END SUBROUTINE read_prop_recon_cont

  ! ---------------------------------------------------------------------------
  SUBROUTINE reconstruct_propagator_dist

    TYPE(propagator), POINTER            :: l  ! left
    TYPE(propagator), POINTER            :: r  ! right
    TYPE(prop_boundary)  :: b

    INTEGER :: prop_type
    INTEGER :: prop_start
    INTEGER :: prop_end
    INTEGER :: prop_left
    INTEGER :: prop_right
    INTEGER :: prop_showall

    INTEGER :: N,i
    INTEGER :: lb1,ub1,lb2,ub2

    INTEGER :: ierr_join
    INTEGER :: iparallel_storage
    LOGICAL :: parallel_storage


    ! from the finally joined propagator
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_p_0               
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_m_N  
    ! 
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_p_N               
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_m_N1

    CHARACTER(len=100) :: prop_cfilename_h5
 
    ! read the information about tags

    if (prop_fileformat .eq. 1) then

       call h5_open('taginfo.h5', h5id)

       call h5_get(h5id, 'prop_write', prop_write)
       call h5_get(h5id, 'tag_first', prop_first_tag)
       call h5_get(h5id, 'tag_last',  prop_last_tag)
       call h5_get(h5id, 'parallel_storage', iparallel_storage)

       parallel_storage = (iparallel_storage .eq. 1)
       
       call h5_close(h5id)

    else
       CALL unit_propagator
       OPEN(unit=prop_unit,file=prop_ctaginfo,status='old', &
            form=prop_format,action='read')
       READ(prop_unit,*) prop_write
       READ(prop_unit,*) prop_first_tag
       READ(prop_unit,*) prop_last_tag
       READ(prop_unit,*) parallel_storage
       CLOSE(unit=prop_unit)
    end if
    
    IF (prop_write .EQ. 1) THEN
       prop_type = 1
    ELSEIF (prop_write .EQ. 2) THEN
       prop_type = 3
    ELSE
       PRINT *, 'No reconstruction possible'
       PRINT *, 'Set prop_write to 1 (period) or 2 (propagator)'
       STOP
    END IF

    if (parallel_storage) then
       ! this is now something which has to be done if the initial results were 
       ! generated by a parallel version of the code
       ! WINNY PAR
       prop_showall = 1
       ! first propagator
       N = prop_first_tag
       CALL construct_propagator
       print *, 'first'
       PRINT *, N,prop_first_tag, prop_last_tag
       prop_start = N
       prop_end   = N
       CALL read_propagator_content(prop_c,prop_type,prop_start,prop_end,prop_showall)
       CALL read_binarysplit_content(prop_c)
       
       print *, prop_c%p%npart,prop_c%p%npass_l,prop_c%p%npass_r
       !print *, prop_c%eta_bs_l%n_ori,prop_c%eta_bs_l%n_split
       !print *, prop_c%eta_bs_r%n_ori,prop_c%eta_bs_r%n_split
       !print *, prop_c%eta_bs_l%x_ori_poi
       !print *, prop_c%eta_bs_r%x_ori_poi
       
       
       print *, ''
       ! other propagators
       CALL construct_propagator    
       DO N = prop_first_tag + 1, prop_last_tag, +1
          print *, 'cont'
          PRINT *, N,prop_first_tag, prop_last_tag
          ! read information
          prop_start = N
          prop_end   = N
          print *, ''
          CALL read_propagator_content(prop_c,prop_type,prop_start,prop_end,prop_showall)
          CALL read_binarysplit_content(prop_c)
          print *, prop_c%prev%p%npart,prop_c%prev%p%npass_l,prop_c%prev%p%npass_r
          print *, prop_c%p%npart,prop_c%p%npass_l,prop_c%p%npass_r
          !print *, prop_c%eta_bs_l%n_ori,prop_c%eta_bs_l%n_split
          !print *, prop_c%eta_bs_r%n_ori,prop_c%eta_bs_r%n_split
          !print *, prop_c%eta_bs_l%x_ori_poi
          !print *, prop_c%eta_bs_r%x_ori_poi
          ! join propagators - intermediate - do not clean c_mat
          prop_c_old => prop_c%prev
          prop_c_new => prop_c
          CALL join_ripples_interface(ierr_join,'inter',0)
          ! write propagator end boundaries
          CALL write_prop_bound_content(prop_c%prev,prop_c,3) ! boundary
          CALL write_propagator_content(prop_c%prev,3,2) ! reduced for joined (2)
       END DO
       !final joining
       print *, ''
       print *, 'final'
       CALL assign_propagator_content(prop_c,prop_c%prev)
       prop_c_old => prop_c%prev
       prop_c_new => prop_c
       CALL join_ripples_interface(ierr_join,'final')
       !prop_a => prop_c%prev    
       CALL write_propagator_content(prop_c%prev,4)
       
       print *, ''
       print *, 'destruct'
       call destruct_all_prop
       ! WINNY PAR END
    end if

    ! read the final joined propagator (from join_ends)
    ! and keep only the fluxes (which are in source)
    ! (only one propagator exists at this moment)
    CALL construct_propagator
    l => prop_c
    prop_start = 0
    prop_end = 0
    prop_showall = 1
    CALL read_propagator_content(l,prop_type,prop_start,prop_end,prop_showall)
    lb1 = LBOUND(l%p%source_p,1)
    ub1 = UBOUND(l%p%source_p,1)
    lb2 = LBOUND(l%p%source_p,2)
    ub2 = UBOUND(l%p%source_p,2)
    ALLOCATE(source_p_0(lb1:ub1,lb2:ub2))
    source_p_0 = l%p%source_p
    lb1 = LBOUND(l%p%source_m,1)
    ub1 = UBOUND(l%p%source_m,1)
    lb2 = LBOUND(l%p%source_m,2)
    ub2 = UBOUND(l%p%source_m,2)
    ALLOCATE(source_m_N(lb1:ub1,lb2:ub2))
    source_m_N = l%p%source_m
    NULLIFY(l)

    !PRINT *, 'source_p_0', SIZE(source_p_0,1),SIZE(source_p_0,2)
    !PRINT *, 'source_m_N', SIZE(source_m_N,1),SIZE(source_m_N,2)

    ! write the results - starting point
    CALL filename_propagator(5,0,prop_last_tag,prop_last_tag)

    if (prop_fileformat .eq. 1) then
       write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))
       call h5_create(prop_cfilename_h5, h5id)

       call h5_add(h5id, 'prop_last_tag', prop_last_tag)
       call h5_add(h5id, 'flux_mr', source_m_N, lbound(source_m_N), ubound(source_m_N))
       
       call h5_close(h5id)       

    else
       call unit_propagator
       open(unit=prop_unit,file=prop_cfilename,status='replace', &
            form=prop_format,action='write')
       write(prop_unit,*) prop_last_tag
       write(prop_unit,*) lbound(source_m_N,1),ubound(source_m_N,1)
       write(prop_unit,*) lbound(source_m_N,2),ubound(source_m_N,2)
       write(prop_unit,*) source_m_N
       close(unit=prop_unit)

    end if
    ! propagators
    r => prop_c ! the first one is the right one
    CALL construct_propagator(1)
    l => prop_c ! the second one is the left one

    DO N = prop_last_tag, prop_first_tag + 1, -1

       PRINT *, N,prop_last_tag, prop_first_tag
       
       ! now read the propagator N into the right (r)
       prop_start = N
       prop_end   = N
       prop_showall = 1
       CALL read_propagator_content(r,prop_type,prop_start,prop_end,prop_showall)
    
       ! read the one from the first to (N-1) into the left (l) propagator
       prop_start = prop_first_tag
       prop_end     = N - 1
       prop_showall = 2
       IF (prop_start .EQ. prop_end) prop_showall = 1
       CALL read_propagator_content(l,prop_type,prop_start,prop_end,prop_showall)

       ! read the boundary between those two
       prop_left  = N - 1
       prop_right = N
       CALL read_prop_bound_cont(b,prop_type,prop_left,prop_right)

       ! do the computation with left (l), right (r), boundary (b)
       CALL reconstruct_prop_dist(l,r,b, &
            source_p_0,source_m_N,source_m_N1,source_p_N)

       ! output of new results
       CALL filename_propagator(5,0,N,N)

       if (prop_fileformat .eq. 1) then
          write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))
          call h5_open_rw(prop_cfilename_h5, h5id)

          call h5_add(h5id, 'flux_pl', source_p_N, lbound(source_p_N), ubound(source_p_N))
          
          call h5_close(h5id)          

       else

          CALL unit_propagator
          OPEN(unit=prop_unit,file=prop_cfilename,status='old', &
               form=prop_format,action='write',position='append')
          ! source_p for N
          WRITE(prop_unit,*) LBOUND(source_p_N,1),UBOUND(source_p_N,1)
          WRITE(prop_unit,*) LBOUND(source_p_N,2),UBOUND(source_p_N,2)
          WRITE(prop_unit,*) source_p_N
          CLOSE(prop_unit)
       end if
       
       CALL filename_propagator(5,0,N-1,N-1)
       
       if (prop_fileformat .eq. 1) then

          write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))
          call h5_create(prop_cfilename_h5, h5id)

          call h5_add(h5id, 'prop_last_tag', N - 1)
          call h5_add(h5id, 'flux_mr', source_m_N1, lbound(source_m_N1), ubound(source_m_N1))

          call h5_close(h5id)  
          
       else
          CALL unit_propagator
          OPEN(unit=prop_unit,file=prop_cfilename,status='replace', &
               form=prop_format,action='write')
          WRITE(prop_unit,*) N - 1
          ! source_m for N-1       
          WRITE(prop_unit,*) LBOUND(source_m_N1,1),UBOUND(source_m_N1,1)
          WRITE(prop_unit,*) LBOUND(source_m_N1,2),UBOUND(source_m_N1,2)
          WRITE(prop_unit,*) source_m_N1
          CLOSE(unit=prop_unit)

       end if
      
       ! now make source_m or N-1 the new starting value
       DEALLOCATE(source_m_N)
!       ALLOCATE(source_m_N(lb1:ub1,lb2:ub2))
       ALLOCATE(source_m_N(SIZE(source_m_N1,1),SIZE(source_m_N1,2))) !<-SERGEI
       source_m_N = source_m_N1
       ! and continue with the backward recurance
    END DO

    ! write the results - final point (from join_ends)
    CALL filename_propagator(5,0,prop_first_tag,prop_first_tag)

    if (prop_fileformat .eq. 1) then

       write(prop_cfilename_h5,'(100A)') trim(adjustl(prop_cfilename))
       call h5_open_rw(prop_cfilename_h5, h5id)

       call h5_add(h5id, 'flux_pl', source_p_0, lbound(source_p_0), ubound(source_p_0))
       
       call h5_close(h5id)
 
    else
       call unit_propagator
       open(unit=prop_unit,file=prop_cfilename,status='old', &
            form=prop_format,action='write',position='append')
       write(prop_unit,*) lbound(source_p_0,1),ubound(source_p_0,1)
       write(prop_unit,*) lbound(source_p_0,2),ubound(source_p_0,2)
       write(prop_unit,*) source_p_0
       close(unit=prop_unit)
    end if


!!$    ! for joining the cmat must go into the propagator
!!$    ! forward goes to the left - l(eft)
!!$    lb1 = LBOUND(b%c_forward,1)
!!$    ub1 = UBOUND(b%c_forward,1)
!!$    lb2 = LBOUND(b%c_forward,2)
!!$    ub2 = UBOUND(b%c_forward,2)
!!$    IF (ALLOCATED(l%p%cmat)) DEALLOCATE(l%p%cmat)
!!$    ALLOCATE(l%p%cmat(lb1:ub1,lb2:ub2))
!!$    l%p%cmat = b%c_forward
!!$    ! backward goes to the right - r(ight)
!!$    lb1 = LBOUND(b%c_backward,1)
!!$    ub1 = UBOUND(b%c_backward,1)
!!$    lb2 = LBOUND(b%c_backward,2)
!!$    ub2 = UBOUND(b%c_backward,2)
!!$    IF (ALLOCATED(r%p%cmat)) DEALLOCATE(r%p%cmat)
!!$    ALLOCATE(r%p%cmat(lb1:ub1,lb2:ub2))
!!$    r%p%cmat = b%c_backward
!!$
!!$    ! when you do joining the result is in prop_c
!!$    prop_c => prop_c%next
!!$    CALL join_ripples(ierr_join)




  END SUBROUTINE reconstruct_propagator_dist

  ! ---------------------------------------------------------------------------
  SUBROUTINE reconstruct_propagator_dist_1(l,r,b, &
       source_p_0,source_m_N,source_m_N1,source_p_N)
!
    USE lapack_band
!
    TYPE(propagator), POINTER            :: l  ! left
    TYPE(propagator), POINTER            :: r  ! right
    TYPE(prop_boundary)  :: b

    INTEGER :: lb1,ub1,lb2,ub2
    INTEGER :: nvel,ndim,ndim1,m,k,k1,info,i


    ! from the finally joined propagator
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_p_0               
    ! from the last iteration
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_m_N  
    ! new results
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_m_N1  
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: source_p_N               

    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: amat,bvec_lapack
    REAL(kind=dp), DIMENSION(:,:),   ALLOCATABLE :: a_mp,a_pm,q_p,q_m
    INTEGER,       DIMENSION(:),     ALLOCATABLE :: ipivot

    IF (ALLOCATED(source_m_N1)) DEALLOCATE(source_m_N1)
    IF (ALLOCATED(source_p_N))  DEALLOCATE(source_p_N)

    ! one has
    !  source_m_N
    !  source_p_0

    ! so what one needs is
    ! source_m_N1     - N1 means N-1
    ! source_p_N

    ! there are two pointers
    ! l : jpoined from the beginning to N-1 
    !     (with limited information) A_p_p,A_m_p,q_p and the sizes)
    ! r : the actual propagator at N 
    !     (with all information) 

    ! there is also the boundary
    ! b : with
    ! b%c_forward
    ! b%c_backward

    ! SERGEI - here comes all the stuff
  nvel = r%p%nvelocity
!
  ndim=r%p%npass_l*(nvel+1)
  ndim1=l%p%npass_r*(nvel+1)
!
  ALLOCATE(amat(ndim,ndim),bvec_lapack(ndim,3),ipivot(ndim))
  ALLOCATE(a_mp(ndim,ndim1),a_pm(ndim1,ndim),q_p(ndim,3),q_m(ndim1,3))
!
  DO m=0,nvel
    k=m*r%p%npass_l
    k1=m*l%p%npass_r
    a_mp(k+1:k+r%p%npass_l,:)                                       &
           =MATMUL(b%c_forward,l%p%amat_m_p(k1+1:k1+l%p%npass_r,:))
    a_pm(k1+1:k1+l%p%npass_r,:)                                     &
           =MATMUL(b%c_backward,r%p%amat_p_m(k+1:k+r%p%npass_l,:))
    q_p(k+1:k+r%p%npass_l,:)                                        &
           =MATMUL(b%c_forward,l%p%source_p(k1+1:k1+l%p%npass_r,:)  &
           +MATMUL(l%p%amat_p_p(k1+1:k1+l%p%npass_r,:),source_p_0))
    q_m(k1+1:k1+l%p%npass_r,:)                                      &
           =MATMUL(b%c_backward,r%p%source_m(k+1:k+r%p%npass_l,:)   &
           +MATMUL(r%p%amat_m_m(k+1:k+r%p%npass_l,:),source_m_N))
  ENDDO
!
! Now the set of equations has the aligned dimensions and is of the form:
! $f^+ = A^{-+} f^- + q^+$
! $f^- = A^{+-} f^+ + q^-$
!
  amat=0.d0
  DO i=1,ndim
    amat(i,i)=1.d0
  ENDDO
  amat=amat-MATMUL(a_mp,a_pm)
  bvec_lapack=q_p+MATMUL(a_mp,q_m)
!
  CALL gbsv(ndim,ndim,amat,ipivot,bvec_lapack,info)
!
  IF(info.NE.0) THEN
    PRINT *,'gbsv error ',info,' in reconstruct_propagator_dist'
    RETURN
  ENDIF
!
  ALLOCATE(source_p_N(ndim,3),source_m_N1(ndim1,3))
!
  source_p_N=bvec_lapack
  source_m_N1=q_m+MATMUL(a_pm,bvec_lapack)
!
  DEALLOCATE(amat,bvec_lapack,ipivot,a_mp,a_pm,q_p,q_m)
!

  END SUBROUTINE reconstruct_propagator_dist_1
  ! ---------------------------------------------------------------------------

  SUBROUTINE unit_prop
    LOGICAL :: opened
    DO
       INQUIRE(unit=prop_unit,opened=opened)
       IF (.NOT. opened) EXIT
       prop_unit = prop_unit + 1
    END DO
  END SUBROUTINE unit_prop
  ! ---------------------------------------------------------------------------

  SUBROUTINE filename_prop(prop_type,prop_bound,prop_start,prop_end)
    !
    ! constructs filenames for Spitzer output
    !
    ! prop_type  - 1,2 : period
    !            - 3,4 : propagator
    !            - 5   : result
    !            - 6   : binarysplit
    ! prop_bound - 0   : is no boundary
    !              1   : is boundary
    !
    ! output is written on prop_cfilename
    !
    INTEGER, INTENT(in) :: prop_type
    INTEGER, INTENT(in) :: prop_bound
    INTEGER, INTENT(in) :: prop_start
    INTEGER, INTENT(in) :: prop_end

    CHARACTER(len=15) :: ctag1,ctag2

    WRITE(ctag1,*) prop_start
    WRITE(ctag2,*) prop_end

    ! NetCDF
    if (prop_fileformat .eq. 2) then
       prop_cext = 'nc'
    elseif (prop_fileformat .eq. 1) then
       prop_cext = 'h5'
    else
       prop_cext = 'prop'
    end if
    
    !write (*,*) 'Setting prop extension to ', prop_cext

    ! choose basename
    IF (prop_type .EQ. 1 .OR. prop_type .EQ. 2) THEN ! period
       prop_cfilename = prop_cperiod
    ELSEIF (prop_type .EQ. 3 .OR. prop_type .EQ. 4) THEN ! propagator
       prop_cfilename = prop_cpropagator
    ELSEIF (prop_type .EQ. 5) THEN ! result
       prop_cfilename = prop_cresult
    ELSEIF (prop_type .EQ. 6) THEN ! binarysplit
       prop_cfilename = prop_cbinarysplit
    END IF

    ! add boundary to name
    IF (prop_bound .EQ. 1) THEN
       WRITE(prop_cfilename,'(100A)') &
         TRIM(ADJUSTL(prop_cfilename)),'_', &
         TRIM(ADJUSTL(prop_cboundary))
    END IF

    ! add numbers and extension

    WRITE(prop_cfilename,'(100A)') &
         TRIM(ADJUSTL(prop_cfilename)),'_', &
         TRIM(ADJUSTL(ctag1)),'_', &
         TRIM(ADJUSTL(ctag2)),'.', &
         TRIM(ADJUSTL(prop_cext))


  END SUBROUTINE filename_prop
  ! ---------------------------------------------------------------------------



END MODULE propagator_mod
